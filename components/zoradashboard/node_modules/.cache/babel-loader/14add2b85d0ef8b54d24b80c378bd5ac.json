{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _linkedList = _interopRequireDefault(require(\"./linkedList\"));\n/* eslint-disable no-restricted-properties */\n\n/**\n * @preserve Knuth and Plass line breaking algorithm in JavaScript\n *\n * Licensed under the new BSD License.\n * Copyright 2009-2010, Bram Stein\n * All rights reserved.\n */\n\n\nvar linebreak = function linebreak(nodes, lines, settings) {\n  var options = {\n    demerits: {\n      line: settings && settings.demerits && settings.demerits.line || 10,\n      flagged: settings && settings.demerits && settings.demerits.flagged || 100,\n      fitness: settings && settings.demerits && settings.demerits.fitness || 3000\n    },\n    tolerance: settings && settings.tolerance || 3\n  };\n  var activeNodes = new _linkedList.default();\n  var sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  var lineLengths = lines;\n  var breaks = [];\n  var tmp = {\n    data: {\n      demerits: Infinity\n    }\n  };\n\n  function breakpoint(position, demerits, ratio, line, fitnessClass, totals, previous) {\n    return {\n      position: position,\n      demerits: demerits,\n      ratio: ratio,\n      line: line,\n      fitnessClass: fitnessClass,\n      totals: totals || {\n        width: 0,\n        stretch: 0,\n        shrink: 0\n      },\n      previous: previous\n    };\n  }\n\n  function computeCost(start, end, active, currentLine) {\n    var width = sum.width - active.totals.width;\n    var stretch = 0;\n    var shrink = 0; // If the current line index is within the list of linelengths, use it, otherwise use\n    // the last line length of the list.\n\n    var lineLength = currentLine < lineLengths.length ? lineLengths[currentLine - 1] : lineLengths[lineLengths.length - 1];\n\n    if (nodes[end].type === 'penalty') {\n      width += nodes[end].width;\n    }\n\n    if (width < lineLength) {\n      // Calculate the stretch ratio\n      stretch = sum.stretch - active.totals.stretch;\n\n      if (stretch > 0) {\n        return (lineLength - width) / stretch;\n      }\n\n      return linebreak.infinity;\n    }\n\n    if (width > lineLength) {\n      // Calculate the shrink ratio\n      shrink = sum.shrink - active.totals.shrink;\n\n      if (shrink > 0) {\n        return (lineLength - width) / shrink;\n      }\n\n      return linebreak.infinity;\n    } // perfect match\n\n\n    return 0;\n  } // Add width, stretch and shrink values from the current\n  // break point up to the next box or forced penalty.\n\n\n  function computeSum(breakPointIndex) {\n    var result = {\n      width: sum.width,\n      stretch: sum.stretch,\n      shrink: sum.shrink\n    };\n\n    for (var i = breakPointIndex; i < nodes.length; i += 1) {\n      if (nodes[i].type === 'glue') {\n        result.width += nodes[i].width;\n        result.stretch += nodes[i].stretch;\n        result.shrink += nodes[i].shrink;\n      } else if (nodes[i].type === 'box' || nodes[i].type === 'penalty' && nodes[i].penalty === -linebreak.infinity && i > breakPointIndex) {\n        break;\n      }\n    }\n\n    return result;\n  } // The main loop of the algorithm\n  // eslint-disable-next-line no-shadow\n\n\n  function mainLoop(node, index, nodes) {\n    var active = activeNodes.first();\n    var next = null;\n    var ratio = 0;\n    var demerits = 0;\n    var candidates = [];\n    var badness;\n    var currentLine = 0;\n    var tmpSum;\n    var currentClass = 0;\n    var fitnessClass;\n    var candidate;\n    var newNode; // The inner loop iterates through all the active nodes with line < currentLine and then\n    // breaks out to insert the new active node candidates before looking at the next active\n    // nodes for the next lines. The result of this is that the active node list is always\n    // sorted by line number.\n\n    while (active !== null) {\n      candidates = [{\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }]; // Iterate through the linked list of active nodes to find new potential active nodes\n      // and deactivate current active nodes.\n\n      while (active !== null) {\n        next = active.next;\n        currentLine = active.data.line + 1;\n        ratio = computeCost(active.data.position, index, active.data, currentLine); // Deactive nodes when the distance between the current active node and the\n        // current node becomes too large (i.e. it exceeds the stretch limit and the stretch\n        // ratio becomes negative) or when the current node is a forced break (i.e. the end\n        // of the paragraph when we want to remove all active nodes, but possibly have a final\n        // candidate active node---if the paragraph can be set using the given tolerance value.)\n\n        if (ratio < -1 || node.type === 'penalty' && node.penalty === -linebreak.infinity) {\n          activeNodes.remove(active);\n        } // If the ratio is within the valid range of -1 <= ratio <= tolerance calculate the\n        // total demerits and record a candidate active node.\n\n\n        if (ratio >= -1 && ratio <= options.tolerance) {\n          badness = 100 * Math.pow(Math.abs(ratio), 3); // Positive penalty\n\n          if (node.type === 'penalty' && node.penalty >= 0) {\n            demerits = Math.pow(options.demerits.line + badness, 2) + Math.pow(node.penalty, 2); // Negative penalty but not a forced break\n          } else if (node.type === 'penalty' && node.penalty !== -linebreak.infinity) {\n            demerits = Math.pow(options.demerits.line + badness, 2) - Math.pow(node.penalty, 2); // All other cases\n          } else {\n            demerits = Math.pow(options.demerits.line + badness, 2);\n          }\n\n          if (node.type === 'penalty' && nodes[active.data.position].type === 'penalty') {\n            demerits += options.demerits.flagged * node.flagged * nodes[active.data.position].flagged;\n          } // Calculate the fitness class for this candidate active node.\n\n\n          if (ratio < -0.5) {\n            currentClass = 0;\n          } else if (ratio <= 0.5) {\n            currentClass = 1;\n          } else if (ratio <= 1) {\n            currentClass = 2;\n          } else {\n            currentClass = 3;\n          } // Add a fitness penalty to the demerits if the fitness classes of two adjacent lines\n          // differ too much.\n\n\n          if (Math.abs(currentClass - active.data.fitnessClass) > 1) {\n            demerits += options.demerits.fitness;\n          } // Add the total demerits of the active node to get the total demerits of this candidate node.\n\n\n          demerits += active.data.demerits; // Only store the best candidate for each fitness class\n\n          if (demerits < candidates[currentClass].demerits) {\n            candidates[currentClass] = {\n              active: active,\n              demerits: demerits,\n              ratio: ratio\n            };\n          }\n        }\n\n        active = next; // Stop iterating through active nodes to insert new candidate active nodes in the active list\n        // before moving on to the active nodes for the next line.\n        // TODO: The Knuth and Plass paper suggests a conditional for currentLine < j0. This means paragraphs\n        // with identical line lengths will not be sorted by line number. Find out if that is a desirable outcome.\n        // For now I left this out, as it only adds minimal overhead to the algorithm and keeping the active node\n        // list sorted has a higher priority.\n\n        if (active !== null && active.data.line >= currentLine) {\n          break;\n        }\n      }\n\n      tmpSum = computeSum(index);\n\n      for (fitnessClass = 0; fitnessClass < candidates.length; fitnessClass += 1) {\n        candidate = candidates[fitnessClass];\n\n        if (candidate.demerits < Infinity) {\n          newNode = new _linkedList.default.Node(breakpoint(index, candidate.demerits, candidate.ratio, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));\n\n          if (active !== null) {\n            activeNodes.insertBefore(active, newNode);\n          } else {\n            activeNodes.push(newNode);\n          }\n        }\n      }\n    }\n  } // Add an active node for the start of the paragraph.\n\n\n  activeNodes.push(new _linkedList.default.Node(breakpoint(0, 0, 0, 0, 0, undefined, null))); // eslint-disable-next-line no-shadow\n\n  nodes.forEach(function (node, index, nodes) {\n    if (node.type === 'box') {\n      sum.width += node.width;\n    } else if (node.type === 'glue') {\n      if (index > 0 && nodes[index - 1].type === 'box') {\n        mainLoop(node, index, nodes);\n      }\n\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n    } else if (node.type === 'penalty' && node.penalty !== linebreak.infinity) {\n      mainLoop(node, index, nodes);\n    }\n  });\n\n  if (activeNodes.size() !== 0) {\n    // Find the best active node (the one with the least total demerits.)\n    activeNodes.forEach(function (node) {\n      if (node.data.demerits < tmp.data.demerits) {\n        tmp = node;\n      }\n    });\n\n    while (tmp !== null) {\n      breaks.push({\n        position: tmp.data.position,\n        ratio: tmp.data.ratio\n      });\n      tmp = tmp.data.previous;\n    }\n\n    return breaks.reverse();\n  }\n\n  return [];\n};\n\nlinebreak.infinity = 10000;\n\nlinebreak.glue = function (width, value, stretch, shrink) {\n  return {\n    type: 'glue',\n    value: value,\n    width: width,\n    stretch: stretch,\n    shrink: shrink\n  };\n};\n\nlinebreak.box = function (width, value, hyphenated) {\n  if (hyphenated === void 0) {\n    hyphenated = false;\n  }\n\n  return {\n    type: 'box',\n    width: width,\n    value: value,\n    hyphenated: hyphenated\n  };\n};\n\nlinebreak.penalty = function (width, penalty, flagged) {\n  return {\n    type: 'penalty',\n    width: width,\n    penalty: penalty,\n    flagged: flagged\n  };\n};\n\nvar _default = linebreak;\nexports.default = _default;","map":{"version":3,"sources":["/Users/allan.chepkoy/cloud/kubeflow/components/zoradashboard/node_modules/@react-pdf/textkit/lib/engines/linebreaker/linebreak.js"],"names":["_interopRequireDefault","require","exports","__esModule","default","_linkedList","linebreak","nodes","lines","settings","options","demerits","line","flagged","fitness","tolerance","activeNodes","sum","width","stretch","shrink","lineLengths","breaks","tmp","data","Infinity","breakpoint","position","ratio","fitnessClass","totals","previous","computeCost","start","end","active","currentLine","lineLength","length","type","infinity","computeSum","breakPointIndex","result","i","penalty","mainLoop","node","index","first","next","candidates","badness","tmpSum","currentClass","candidate","newNode","remove","Math","pow","abs","Node","insertBefore","push","undefined","forEach","size","reverse","glue","value","box","hyphenated","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _linkedList = _interopRequireDefault(require(\"./linkedList\"));\n\n/* eslint-disable no-restricted-properties */\n\n/**\n * @preserve Knuth and Plass line breaking algorithm in JavaScript\n *\n * Licensed under the new BSD License.\n * Copyright 2009-2010, Bram Stein\n * All rights reserved.\n */\nvar linebreak = function linebreak(nodes, lines, settings) {\n  var options = {\n    demerits: {\n      line: settings && settings.demerits && settings.demerits.line || 10,\n      flagged: settings && settings.demerits && settings.demerits.flagged || 100,\n      fitness: settings && settings.demerits && settings.demerits.fitness || 3000\n    },\n    tolerance: settings && settings.tolerance || 3\n  };\n  var activeNodes = new _linkedList.default();\n  var sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  var lineLengths = lines;\n  var breaks = [];\n  var tmp = {\n    data: {\n      demerits: Infinity\n    }\n  };\n\n  function breakpoint(position, demerits, ratio, line, fitnessClass, totals, previous) {\n    return {\n      position: position,\n      demerits: demerits,\n      ratio: ratio,\n      line: line,\n      fitnessClass: fitnessClass,\n      totals: totals || {\n        width: 0,\n        stretch: 0,\n        shrink: 0\n      },\n      previous: previous\n    };\n  }\n\n  function computeCost(start, end, active, currentLine) {\n    var width = sum.width - active.totals.width;\n    var stretch = 0;\n    var shrink = 0; // If the current line index is within the list of linelengths, use it, otherwise use\n    // the last line length of the list.\n\n    var lineLength = currentLine < lineLengths.length ? lineLengths[currentLine - 1] : lineLengths[lineLengths.length - 1];\n\n    if (nodes[end].type === 'penalty') {\n      width += nodes[end].width;\n    }\n\n    if (width < lineLength) {\n      // Calculate the stretch ratio\n      stretch = sum.stretch - active.totals.stretch;\n\n      if (stretch > 0) {\n        return (lineLength - width) / stretch;\n      }\n\n      return linebreak.infinity;\n    }\n\n    if (width > lineLength) {\n      // Calculate the shrink ratio\n      shrink = sum.shrink - active.totals.shrink;\n\n      if (shrink > 0) {\n        return (lineLength - width) / shrink;\n      }\n\n      return linebreak.infinity;\n    } // perfect match\n\n\n    return 0;\n  } // Add width, stretch and shrink values from the current\n  // break point up to the next box or forced penalty.\n\n\n  function computeSum(breakPointIndex) {\n    var result = {\n      width: sum.width,\n      stretch: sum.stretch,\n      shrink: sum.shrink\n    };\n\n    for (var i = breakPointIndex; i < nodes.length; i += 1) {\n      if (nodes[i].type === 'glue') {\n        result.width += nodes[i].width;\n        result.stretch += nodes[i].stretch;\n        result.shrink += nodes[i].shrink;\n      } else if (nodes[i].type === 'box' || nodes[i].type === 'penalty' && nodes[i].penalty === -linebreak.infinity && i > breakPointIndex) {\n        break;\n      }\n    }\n\n    return result;\n  } // The main loop of the algorithm\n  // eslint-disable-next-line no-shadow\n\n\n  function mainLoop(node, index, nodes) {\n    var active = activeNodes.first();\n    var next = null;\n    var ratio = 0;\n    var demerits = 0;\n    var candidates = [];\n    var badness;\n    var currentLine = 0;\n    var tmpSum;\n    var currentClass = 0;\n    var fitnessClass;\n    var candidate;\n    var newNode; // The inner loop iterates through all the active nodes with line < currentLine and then\n    // breaks out to insert the new active node candidates before looking at the next active\n    // nodes for the next lines. The result of this is that the active node list is always\n    // sorted by line number.\n\n    while (active !== null) {\n      candidates = [{\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }, {\n        demerits: Infinity\n      }]; // Iterate through the linked list of active nodes to find new potential active nodes\n      // and deactivate current active nodes.\n\n      while (active !== null) {\n        next = active.next;\n        currentLine = active.data.line + 1;\n        ratio = computeCost(active.data.position, index, active.data, currentLine); // Deactive nodes when the distance between the current active node and the\n        // current node becomes too large (i.e. it exceeds the stretch limit and the stretch\n        // ratio becomes negative) or when the current node is a forced break (i.e. the end\n        // of the paragraph when we want to remove all active nodes, but possibly have a final\n        // candidate active node---if the paragraph can be set using the given tolerance value.)\n\n        if (ratio < -1 || node.type === 'penalty' && node.penalty === -linebreak.infinity) {\n          activeNodes.remove(active);\n        } // If the ratio is within the valid range of -1 <= ratio <= tolerance calculate the\n        // total demerits and record a candidate active node.\n\n\n        if (ratio >= -1 && ratio <= options.tolerance) {\n          badness = 100 * Math.pow(Math.abs(ratio), 3); // Positive penalty\n\n          if (node.type === 'penalty' && node.penalty >= 0) {\n            demerits = Math.pow(options.demerits.line + badness, 2) + Math.pow(node.penalty, 2); // Negative penalty but not a forced break\n          } else if (node.type === 'penalty' && node.penalty !== -linebreak.infinity) {\n            demerits = Math.pow(options.demerits.line + badness, 2) - Math.pow(node.penalty, 2); // All other cases\n          } else {\n            demerits = Math.pow(options.demerits.line + badness, 2);\n          }\n\n          if (node.type === 'penalty' && nodes[active.data.position].type === 'penalty') {\n            demerits += options.demerits.flagged * node.flagged * nodes[active.data.position].flagged;\n          } // Calculate the fitness class for this candidate active node.\n\n\n          if (ratio < -0.5) {\n            currentClass = 0;\n          } else if (ratio <= 0.5) {\n            currentClass = 1;\n          } else if (ratio <= 1) {\n            currentClass = 2;\n          } else {\n            currentClass = 3;\n          } // Add a fitness penalty to the demerits if the fitness classes of two adjacent lines\n          // differ too much.\n\n\n          if (Math.abs(currentClass - active.data.fitnessClass) > 1) {\n            demerits += options.demerits.fitness;\n          } // Add the total demerits of the active node to get the total demerits of this candidate node.\n\n\n          demerits += active.data.demerits; // Only store the best candidate for each fitness class\n\n          if (demerits < candidates[currentClass].demerits) {\n            candidates[currentClass] = {\n              active: active,\n              demerits: demerits,\n              ratio: ratio\n            };\n          }\n        }\n\n        active = next; // Stop iterating through active nodes to insert new candidate active nodes in the active list\n        // before moving on to the active nodes for the next line.\n        // TODO: The Knuth and Plass paper suggests a conditional for currentLine < j0. This means paragraphs\n        // with identical line lengths will not be sorted by line number. Find out if that is a desirable outcome.\n        // For now I left this out, as it only adds minimal overhead to the algorithm and keeping the active node\n        // list sorted has a higher priority.\n\n        if (active !== null && active.data.line >= currentLine) {\n          break;\n        }\n      }\n\n      tmpSum = computeSum(index);\n\n      for (fitnessClass = 0; fitnessClass < candidates.length; fitnessClass += 1) {\n        candidate = candidates[fitnessClass];\n\n        if (candidate.demerits < Infinity) {\n          newNode = new _linkedList.default.Node(breakpoint(index, candidate.demerits, candidate.ratio, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));\n\n          if (active !== null) {\n            activeNodes.insertBefore(active, newNode);\n          } else {\n            activeNodes.push(newNode);\n          }\n        }\n      }\n    }\n  } // Add an active node for the start of the paragraph.\n\n\n  activeNodes.push(new _linkedList.default.Node(breakpoint(0, 0, 0, 0, 0, undefined, null))); // eslint-disable-next-line no-shadow\n\n  nodes.forEach(function (node, index, nodes) {\n    if (node.type === 'box') {\n      sum.width += node.width;\n    } else if (node.type === 'glue') {\n      if (index > 0 && nodes[index - 1].type === 'box') {\n        mainLoop(node, index, nodes);\n      }\n\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n    } else if (node.type === 'penalty' && node.penalty !== linebreak.infinity) {\n      mainLoop(node, index, nodes);\n    }\n  });\n\n  if (activeNodes.size() !== 0) {\n    // Find the best active node (the one with the least total demerits.)\n    activeNodes.forEach(function (node) {\n      if (node.data.demerits < tmp.data.demerits) {\n        tmp = node;\n      }\n    });\n\n    while (tmp !== null) {\n      breaks.push({\n        position: tmp.data.position,\n        ratio: tmp.data.ratio\n      });\n      tmp = tmp.data.previous;\n    }\n\n    return breaks.reverse();\n  }\n\n  return [];\n};\n\nlinebreak.infinity = 10000;\n\nlinebreak.glue = function (width, value, stretch, shrink) {\n  return {\n    type: 'glue',\n    value: value,\n    width: width,\n    stretch: stretch,\n    shrink: shrink\n  };\n};\n\nlinebreak.box = function (width, value, hyphenated) {\n  if (hyphenated === void 0) {\n    hyphenated = false;\n  }\n\n  return {\n    type: 'box',\n    width: width,\n    value: value,\n    hyphenated: hyphenated\n  };\n};\n\nlinebreak.penalty = function (width, penalty, flagged) {\n  return {\n    type: 'penalty',\n    width: width,\n    penalty: penalty,\n    flagged: flagged\n  };\n};\n\nvar _default = linebreak;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}