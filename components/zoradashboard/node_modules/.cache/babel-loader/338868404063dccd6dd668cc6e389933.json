{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar TAU = Math.PI * 2;\n\nvar mapToEllipse = function mapToEllipse(_ref, rx, ry, cosphi, sinphi, centerx, centery) {\n  var x = _ref.x,\n      y = _ref.y;\n  x *= rx;\n  y *= ry;\n  var xp = cosphi * x - sinphi * y;\n  var yp = sinphi * x + cosphi * y;\n  return {\n    x: xp + centerx,\n    y: yp + centery\n  };\n};\n\nvar approxUnitArc = function approxUnitArc(ang1, ang2) {\n  // If 90 degree circular arc, use a constant\n  // as derived from http://spencermortensen.com/articles/bezier-circle\n  var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n  var x1 = Math.cos(ang1);\n  var y1 = Math.sin(ang1);\n  var x2 = Math.cos(ang1 + ang2);\n  var y2 = Math.sin(ang1 + ang2);\n  return [{\n    x: x1 - y1 * a,\n    y: y1 + x1 * a\n  }, {\n    x: x2 + y2 * a,\n    y: y2 - x2 * a\n  }, {\n    x: x2,\n    y: y2\n  }];\n};\n\nvar vectorAngle = function vectorAngle(ux, uy, vx, vy) {\n  var sign = ux * vy - uy * vx < 0 ? -1 : 1;\n  var dot = ux * vx + uy * vy;\n\n  if (dot > 1) {\n    dot = 1;\n  }\n\n  if (dot < -1) {\n    dot = -1;\n  }\n\n  return sign * Math.acos(dot);\n};\n\nvar getArcCenter = function getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {\n  var rxsq = Math.pow(rx, 2);\n  var rysq = Math.pow(ry, 2);\n  var pxpsq = Math.pow(pxp, 2);\n  var pypsq = Math.pow(pyp, 2);\n  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;\n\n  if (radicant < 0) {\n    radicant = 0;\n  }\n\n  radicant /= rxsq * pypsq + rysq * pxpsq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n  var centerxp = radicant * rx / ry * pyp;\n  var centeryp = radicant * -ry / rx * pxp;\n  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;\n  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;\n  var vx1 = (pxp - centerxp) / rx;\n  var vy1 = (pyp - centeryp) / ry;\n  var vx2 = (-pxp - centerxp) / rx;\n  var vy2 = (-pyp - centeryp) / ry;\n  var ang1 = vectorAngle(1, 0, vx1, vy1);\n  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n\n  return [centerx, centery, ang1, ang2];\n};\n\nvar arcToBezier = function arcToBezier(_ref2) {\n  var px = _ref2.px,\n      py = _ref2.py,\n      cx = _ref2.cx,\n      cy = _ref2.cy,\n      rx = _ref2.rx,\n      ry = _ref2.ry,\n      _ref2$xAxisRotation = _ref2.xAxisRotation,\n      xAxisRotation = _ref2$xAxisRotation === undefined ? 0 : _ref2$xAxisRotation,\n      _ref2$largeArcFlag = _ref2.largeArcFlag,\n      largeArcFlag = _ref2$largeArcFlag === undefined ? 0 : _ref2$largeArcFlag,\n      _ref2$sweepFlag = _ref2.sweepFlag,\n      sweepFlag = _ref2$sweepFlag === undefined ? 0 : _ref2$sweepFlag;\n  var curves = [];\n\n  if (rx === 0 || ry === 0) {\n    return [];\n  }\n\n  var sinphi = Math.sin(xAxisRotation * TAU / 360);\n  var cosphi = Math.cos(xAxisRotation * TAU / 360);\n  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;\n  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;\n\n  if (pxp === 0 && pyp === 0) {\n    return [];\n  }\n\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n\n  var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp),\n      _getArcCenter2 = _slicedToArray(_getArcCenter, 4),\n      centerx = _getArcCenter2[0],\n      centery = _getArcCenter2[1],\n      ang1 = _getArcCenter2[2],\n      ang2 = _getArcCenter2[3]; // If 'ang2' == 90.0000000001, then `ratio` will evaluate to\n  // 1.0000000001. This causes `segments` to be greater than one, which is an\n  // unecessary split, and adds extra points to the bezier curve. To alleviate\n  // this issue, we round to 1.0 when the ratio is close to 1.0.\n\n\n  var ratio = Math.abs(ang2) / (TAU / 4);\n\n  if (Math.abs(1.0 - ratio) < 0.0000001) {\n    ratio = 1.0;\n  }\n\n  var segments = Math.max(Math.ceil(ratio), 1);\n  ang2 /= segments;\n\n  for (var i = 0; i < segments; i++) {\n    curves.push(approxUnitArc(ang1, ang2));\n    ang1 += ang2;\n  }\n\n  return curves.map(function (curve) {\n    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery),\n        x1 = _mapToEllipse.x,\n        y1 = _mapToEllipse.y;\n\n    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery),\n        x2 = _mapToEllipse2.x,\n        y2 = _mapToEllipse2.y;\n\n    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery),\n        x = _mapToEllipse3.x,\n        y = _mapToEllipse3.y;\n\n    return {\n      x1: x1,\n      y1: y1,\n      x2: x2,\n      y2: y2,\n      x: x,\n      y: y\n    };\n  });\n};\n\nexports.default = arcToBezier;\nmodule.exports = exports.default;","map":{"version":3,"sources":["/Users/allan.chepkoy/cloud/kubeflow/components/zoradashboard/node_modules/svg-arc-to-cubic-bezier/cjs/index.js"],"names":["Object","defineProperty","exports","value","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","length","err","Array","isArray","TypeError","TAU","Math","PI","mapToEllipse","_ref","rx","ry","cosphi","sinphi","centerx","centery","x","y","xp","yp","approxUnitArc","ang1","ang2","a","tan","x1","cos","y1","sin","x2","y2","vectorAngle","ux","uy","vx","vy","sign","dot","acos","getArcCenter","px","py","cx","cy","largeArcFlag","sweepFlag","pxp","pyp","rxsq","pow","rysq","pxpsq","pypsq","radicant","sqrt","centerxp","centeryp","vx1","vy1","vx2","vy2","arcToBezier","_ref2","_ref2$xAxisRotation","xAxisRotation","_ref2$largeArcFlag","_ref2$sweepFlag","curves","abs","lambda","_getArcCenter","_getArcCenter2","ratio","segments","max","ceil","map","curve","_mapToEllipse","_mapToEllipse2","_mapToEllipse3","default","module"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar TAU = Math.PI * 2;\n\nvar mapToEllipse = function mapToEllipse(_ref, rx, ry, cosphi, sinphi, centerx, centery) {\n  var x = _ref.x,\n      y = _ref.y;\n\n  x *= rx;\n  y *= ry;\n\n  var xp = cosphi * x - sinphi * y;\n  var yp = sinphi * x + cosphi * y;\n\n  return {\n    x: xp + centerx,\n    y: yp + centery\n  };\n};\n\nvar approxUnitArc = function approxUnitArc(ang1, ang2) {\n  // If 90 degree circular arc, use a constant\n  // as derived from http://spencermortensen.com/articles/bezier-circle\n  var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n\n  var x1 = Math.cos(ang1);\n  var y1 = Math.sin(ang1);\n  var x2 = Math.cos(ang1 + ang2);\n  var y2 = Math.sin(ang1 + ang2);\n\n  return [{\n    x: x1 - y1 * a,\n    y: y1 + x1 * a\n  }, {\n    x: x2 + y2 * a,\n    y: y2 - x2 * a\n  }, {\n    x: x2,\n    y: y2\n  }];\n};\n\nvar vectorAngle = function vectorAngle(ux, uy, vx, vy) {\n  var sign = ux * vy - uy * vx < 0 ? -1 : 1;\n\n  var dot = ux * vx + uy * vy;\n\n  if (dot > 1) {\n    dot = 1;\n  }\n\n  if (dot < -1) {\n    dot = -1;\n  }\n\n  return sign * Math.acos(dot);\n};\n\nvar getArcCenter = function getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {\n  var rxsq = Math.pow(rx, 2);\n  var rysq = Math.pow(ry, 2);\n  var pxpsq = Math.pow(pxp, 2);\n  var pypsq = Math.pow(pyp, 2);\n\n  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;\n\n  if (radicant < 0) {\n    radicant = 0;\n  }\n\n  radicant /= rxsq * pypsq + rysq * pxpsq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n\n  var centerxp = radicant * rx / ry * pyp;\n  var centeryp = radicant * -ry / rx * pxp;\n\n  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;\n  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;\n\n  var vx1 = (pxp - centerxp) / rx;\n  var vy1 = (pyp - centeryp) / ry;\n  var vx2 = (-pxp - centerxp) / rx;\n  var vy2 = (-pyp - centeryp) / ry;\n\n  var ang1 = vectorAngle(1, 0, vx1, vy1);\n  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n\n  return [centerx, centery, ang1, ang2];\n};\n\nvar arcToBezier = function arcToBezier(_ref2) {\n  var px = _ref2.px,\n      py = _ref2.py,\n      cx = _ref2.cx,\n      cy = _ref2.cy,\n      rx = _ref2.rx,\n      ry = _ref2.ry,\n      _ref2$xAxisRotation = _ref2.xAxisRotation,\n      xAxisRotation = _ref2$xAxisRotation === undefined ? 0 : _ref2$xAxisRotation,\n      _ref2$largeArcFlag = _ref2.largeArcFlag,\n      largeArcFlag = _ref2$largeArcFlag === undefined ? 0 : _ref2$largeArcFlag,\n      _ref2$sweepFlag = _ref2.sweepFlag,\n      sweepFlag = _ref2$sweepFlag === undefined ? 0 : _ref2$sweepFlag;\n\n  var curves = [];\n\n  if (rx === 0 || ry === 0) {\n    return [];\n  }\n\n  var sinphi = Math.sin(xAxisRotation * TAU / 360);\n  var cosphi = Math.cos(xAxisRotation * TAU / 360);\n\n  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;\n  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;\n\n  if (pxp === 0 && pyp === 0) {\n    return [];\n  }\n\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n\n  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n\n  var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp),\n      _getArcCenter2 = _slicedToArray(_getArcCenter, 4),\n      centerx = _getArcCenter2[0],\n      centery = _getArcCenter2[1],\n      ang1 = _getArcCenter2[2],\n      ang2 = _getArcCenter2[3];\n\n  // If 'ang2' == 90.0000000001, then `ratio` will evaluate to\n  // 1.0000000001. This causes `segments` to be greater than one, which is an\n  // unecessary split, and adds extra points to the bezier curve. To alleviate\n  // this issue, we round to 1.0 when the ratio is close to 1.0.\n\n\n  var ratio = Math.abs(ang2) / (TAU / 4);\n  if (Math.abs(1.0 - ratio) < 0.0000001) {\n    ratio = 1.0;\n  }\n\n  var segments = Math.max(Math.ceil(ratio), 1);\n\n  ang2 /= segments;\n\n  for (var i = 0; i < segments; i++) {\n    curves.push(approxUnitArc(ang1, ang2));\n    ang1 += ang2;\n  }\n\n  return curves.map(function (curve) {\n    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery),\n        x1 = _mapToEllipse.x,\n        y1 = _mapToEllipse.y;\n\n    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery),\n        x2 = _mapToEllipse2.x,\n        y2 = _mapToEllipse2.y;\n\n    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery),\n        x = _mapToEllipse3.x,\n        y = _mapToEllipse3.y;\n\n    return { x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y };\n  });\n};\n\nexports.default = arcToBezier;\nmodule.exports = exports.default;"]},"metadata":{},"sourceType":"script"}