{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst sections = require('section-matter');\n\nconst defaults = require('./lib/defaults');\n\nconst stringify = require('./lib/stringify');\n\nconst excerpt = require('./lib/excerpt');\n\nconst engines = require('./lib/engines');\n\nconst toFile = require('./lib/to-file');\n\nconst parse = require('./lib/parse');\n\nconst utils = require('./lib/utils');\n/**\n * Takes a string or object with `content` property, extracts\n * and parses front-matter from the string, then returns an object\n * with `data`, `content` and other [useful properties](#returned-object).\n *\n * ```js\n * const matter = require('gray-matter');\n * console.log(matter('---\\ntitle: Home\\n---\\nOther stuff'));\n * //=> { data: { title: 'Home'}, content: 'Other stuff' }\n * ```\n * @param {Object|String} `input` String, or object with `content` string\n * @param {Object} `options`\n * @return {Object}\n * @api public\n */\n\n\nfunction matter(input, options) {\n  if (input === '') {\n    return {\n      data: {},\n      content: input,\n      excerpt: '',\n      orig: input\n    };\n  }\n\n  let file = toFile(input);\n  const cached = matter.cache[file.content];\n\n  if (!options) {\n    if (cached) {\n      file = Object.assign({}, cached);\n      file.orig = cached.orig;\n      return file;\n    } // only cache if there are no options passed. if we cache when options\n    // are passed, we would need to also cache options values, which would\n    // negate any performance benefits of caching\n\n\n    matter.cache[file.content] = file;\n  }\n\n  return parseMatter(file, options);\n}\n/**\n * Parse front matter\n */\n\n\nfunction parseMatter(file, options) {\n  const opts = defaults(options);\n  const open = opts.delimiters[0];\n  const close = '\\n' + opts.delimiters[1];\n  let str = file.content;\n\n  if (opts.language) {\n    file.language = opts.language;\n  } // get the length of the opening delimiter\n\n\n  const openLen = open.length;\n\n  if (!utils.startsWith(str, open, openLen)) {\n    excerpt(file, opts);\n    return file;\n  } // if the next character after the opening delimiter is\n  // a character from the delimiter, then it's not a front-\n  // matter delimiter\n\n\n  if (str.charAt(openLen) === open.slice(-1)) {\n    return file;\n  } // strip the opening delimiter\n\n\n  str = str.slice(openLen);\n  const len = str.length; // use the language defined after first delimiter, if it exists\n\n  const language = matter.language(str, opts);\n\n  if (language.name) {\n    file.language = language.name;\n    str = str.slice(language.raw.length);\n  } // get the index of the closing delimiter\n\n\n  let closeIndex = str.indexOf(close);\n\n  if (closeIndex === -1) {\n    closeIndex = len;\n  } // get the raw front-matter block\n\n\n  file.matter = str.slice(0, closeIndex);\n  const block = file.matter.replace(/^\\s*#[^\\n]+/gm, '').trim();\n\n  if (block === '') {\n    file.isEmpty = true;\n    file.empty = file.content;\n    file.data = {};\n  } else {\n    // create file.data by parsing the raw file.matter block\n    file.data = parse(file.language, file.matter, opts);\n  } // update file.content\n\n\n  if (closeIndex === len) {\n    file.content = '';\n  } else {\n    file.content = str.slice(closeIndex + close.length);\n\n    if (file.content[0] === '\\r') {\n      file.content = file.content.slice(1);\n    }\n\n    if (file.content[0] === '\\n') {\n      file.content = file.content.slice(1);\n    }\n  }\n\n  excerpt(file, opts);\n\n  if (opts.sections === true || typeof opts.section === 'function') {\n    sections(file, opts.section);\n  }\n\n  return file;\n}\n/**\n * Expose engines\n */\n\n\nmatter.engines = engines;\n/**\n * Stringify an object to YAML or the specified language, and\n * append it to the given string. By default, only YAML and JSON\n * can be stringified. See the [engines](#engines) section to learn\n * how to stringify other languages.\n *\n * ```js\n * console.log(matter.stringify('foo bar baz', {title: 'Home'}));\n * // results in:\n * // ---\n * // title: Home\n * // ---\n * // foo bar baz\n * ```\n * @param {String|Object} `file` The content string to append to stringified front-matter, or a file object with `file.content` string.\n * @param {Object} `data` Front matter to stringify.\n * @param {Object} `options` [Options](#options) to pass to gray-matter and [js-yaml].\n * @return {String} Returns a string created by wrapping stringified yaml with delimiters, and appending that to the given string.\n * @api public\n */\n\nmatter.stringify = function (file, data, options) {\n  if (typeof file === 'string') file = matter(file, options);\n  return stringify(file, data, options);\n};\n/**\n * Synchronously read a file from the file system and parse\n * front matter. Returns the same object as the [main function](#matter).\n *\n * ```js\n * const file = matter.read('./content/blog-post.md');\n * ```\n * @param {String} `filepath` file path of the file to read.\n * @param {Object} `options` [Options](#options) to pass to gray-matter.\n * @return {Object} Returns [an object](#returned-object) with `data` and `content`\n * @api public\n */\n\n\nmatter.read = function (filepath, options) {\n  const str = fs.readFileSync(filepath, 'utf8');\n  const file = matter(str, options);\n  file.path = filepath;\n  return file;\n};\n/**\n * Returns true if the given `string` has front matter.\n * @param  {String} `string`\n * @param  {Object} `options`\n * @return {Boolean} True if front matter exists.\n * @api public\n */\n\n\nmatter.test = function (str, options) {\n  return utils.startsWith(str, defaults(options).delimiters[0]);\n};\n/**\n * Detect the language to use, if one is defined after the\n * first front-matter delimiter.\n * @param  {String} `string`\n * @param  {Object} `options`\n * @return {Object} Object with `raw` (actual language string), and `name`, the language with whitespace trimmed\n */\n\n\nmatter.language = function (str, options) {\n  const opts = defaults(options);\n  const open = opts.delimiters[0];\n\n  if (matter.test(str)) {\n    str = str.slice(open.length);\n  }\n\n  const language = str.slice(0, str.search(/\\r?\\n/));\n  return {\n    raw: language,\n    name: language ? language.trim() : ''\n  };\n};\n/**\n * Expose `matter`\n */\n\n\nmatter.cache = {};\n\nmatter.clearCache = function () {\n  matter.cache = {};\n};\n\nmodule.exports = matter;","map":{"version":3,"sources":["/Users/allan.chepkoy/cloud/kubeflow/components/zoradashboard/node_modules/gray-matter/index.js"],"names":["fs","require","sections","defaults","stringify","excerpt","engines","toFile","parse","utils","matter","input","options","data","content","orig","file","cached","cache","Object","assign","parseMatter","opts","open","delimiters","close","str","language","openLen","length","startsWith","charAt","slice","len","name","raw","closeIndex","indexOf","block","replace","trim","isEmpty","empty","section","read","filepath","readFileSync","path","test","search","clearCache","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst fs = require('fs');\nconst sections = require('section-matter');\nconst defaults = require('./lib/defaults');\nconst stringify = require('./lib/stringify');\nconst excerpt = require('./lib/excerpt');\nconst engines = require('./lib/engines');\nconst toFile = require('./lib/to-file');\nconst parse = require('./lib/parse');\nconst utils = require('./lib/utils');\n\n/**\n * Takes a string or object with `content` property, extracts\n * and parses front-matter from the string, then returns an object\n * with `data`, `content` and other [useful properties](#returned-object).\n *\n * ```js\n * const matter = require('gray-matter');\n * console.log(matter('---\\ntitle: Home\\n---\\nOther stuff'));\n * //=> { data: { title: 'Home'}, content: 'Other stuff' }\n * ```\n * @param {Object|String} `input` String, or object with `content` string\n * @param {Object} `options`\n * @return {Object}\n * @api public\n */\n\nfunction matter(input, options) {\n  if (input === '') {\n    return { data: {}, content: input, excerpt: '', orig: input };\n  }\n\n  let file = toFile(input);\n  const cached = matter.cache[file.content];\n\n  if (!options) {\n    if (cached) {\n      file = Object.assign({}, cached);\n      file.orig = cached.orig;\n      return file;\n    }\n\n    // only cache if there are no options passed. if we cache when options\n    // are passed, we would need to also cache options values, which would\n    // negate any performance benefits of caching\n    matter.cache[file.content] = file;\n  }\n\n  return parseMatter(file, options);\n}\n\n/**\n * Parse front matter\n */\n\nfunction parseMatter(file, options) {\n  const opts = defaults(options);\n  const open = opts.delimiters[0];\n  const close = '\\n' + opts.delimiters[1];\n  let str = file.content;\n\n  if (opts.language) {\n    file.language = opts.language;\n  }\n\n  // get the length of the opening delimiter\n  const openLen = open.length;\n  if (!utils.startsWith(str, open, openLen)) {\n    excerpt(file, opts);\n    return file;\n  }\n\n  // if the next character after the opening delimiter is\n  // a character from the delimiter, then it's not a front-\n  // matter delimiter\n  if (str.charAt(openLen) === open.slice(-1)) {\n    return file;\n  }\n\n  // strip the opening delimiter\n  str = str.slice(openLen);\n  const len = str.length;\n\n  // use the language defined after first delimiter, if it exists\n  const language = matter.language(str, opts);\n  if (language.name) {\n    file.language = language.name;\n    str = str.slice(language.raw.length);\n  }\n\n  // get the index of the closing delimiter\n  let closeIndex = str.indexOf(close);\n  if (closeIndex === -1) {\n    closeIndex = len;\n  }\n\n  // get the raw front-matter block\n  file.matter = str.slice(0, closeIndex);\n\n  const block = file.matter.replace(/^\\s*#[^\\n]+/gm, '').trim();\n  if (block === '') {\n    file.isEmpty = true;\n    file.empty = file.content;\n    file.data = {};\n  } else {\n\n    // create file.data by parsing the raw file.matter block\n    file.data = parse(file.language, file.matter, opts);\n  }\n\n  // update file.content\n  if (closeIndex === len) {\n    file.content = '';\n  } else {\n    file.content = str.slice(closeIndex + close.length);\n    if (file.content[0] === '\\r') {\n      file.content = file.content.slice(1);\n    }\n    if (file.content[0] === '\\n') {\n      file.content = file.content.slice(1);\n    }\n  }\n\n  excerpt(file, opts);\n\n  if (opts.sections === true || typeof opts.section === 'function') {\n    sections(file, opts.section);\n  }\n  return file;\n}\n\n/**\n * Expose engines\n */\n\nmatter.engines = engines;\n\n/**\n * Stringify an object to YAML or the specified language, and\n * append it to the given string. By default, only YAML and JSON\n * can be stringified. See the [engines](#engines) section to learn\n * how to stringify other languages.\n *\n * ```js\n * console.log(matter.stringify('foo bar baz', {title: 'Home'}));\n * // results in:\n * // ---\n * // title: Home\n * // ---\n * // foo bar baz\n * ```\n * @param {String|Object} `file` The content string to append to stringified front-matter, or a file object with `file.content` string.\n * @param {Object} `data` Front matter to stringify.\n * @param {Object} `options` [Options](#options) to pass to gray-matter and [js-yaml].\n * @return {String} Returns a string created by wrapping stringified yaml with delimiters, and appending that to the given string.\n * @api public\n */\n\nmatter.stringify = function(file, data, options) {\n  if (typeof file === 'string') file = matter(file, options);\n  return stringify(file, data, options);\n};\n\n/**\n * Synchronously read a file from the file system and parse\n * front matter. Returns the same object as the [main function](#matter).\n *\n * ```js\n * const file = matter.read('./content/blog-post.md');\n * ```\n * @param {String} `filepath` file path of the file to read.\n * @param {Object} `options` [Options](#options) to pass to gray-matter.\n * @return {Object} Returns [an object](#returned-object) with `data` and `content`\n * @api public\n */\n\nmatter.read = function(filepath, options) {\n  const str = fs.readFileSync(filepath, 'utf8');\n  const file = matter(str, options);\n  file.path = filepath;\n  return file;\n};\n\n/**\n * Returns true if the given `string` has front matter.\n * @param  {String} `string`\n * @param  {Object} `options`\n * @return {Boolean} True if front matter exists.\n * @api public\n */\n\nmatter.test = function(str, options) {\n  return utils.startsWith(str, defaults(options).delimiters[0]);\n};\n\n/**\n * Detect the language to use, if one is defined after the\n * first front-matter delimiter.\n * @param  {String} `string`\n * @param  {Object} `options`\n * @return {Object} Object with `raw` (actual language string), and `name`, the language with whitespace trimmed\n */\n\nmatter.language = function(str, options) {\n  const opts = defaults(options);\n  const open = opts.delimiters[0];\n\n  if (matter.test(str)) {\n    str = str.slice(open.length);\n  }\n\n  const language = str.slice(0, str.search(/\\r?\\n/));\n  return {\n    raw: language,\n    name: language ? language.trim() : ''\n  };\n};\n\n/**\n * Expose `matter`\n */\n\nmatter.cache = {};\nmatter.clearCache = function() {\n  matter.cache = {};\n};\nmodule.exports = matter;\n"]},"metadata":{},"sourceType":"script"}