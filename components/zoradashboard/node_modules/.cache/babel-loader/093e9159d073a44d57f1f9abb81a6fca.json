{"ast":null,"code":"'use strict';\n\nvar Buffer = require('buffer').Buffer;\n\nvar Transform = require('stream').Transform;\n\nvar binding = require('./binding');\n\nvar util = require('util');\n\nvar assert = require('assert').ok;\n\nvar kMaxLength = require('buffer').kMaxLength;\n\nvar kRangeErrorMessage = 'Cannot create final Buffer. It would be larger ' + 'than 0x' + kMaxLength.toString(16) + ' bytes'; // zlib doesn't provide these, so kludge them in following the same\n// const naming scheme zlib uses.\n\nbinding.Z_MIN_WINDOWBITS = 8;\nbinding.Z_MAX_WINDOWBITS = 15;\nbinding.Z_DEFAULT_WINDOWBITS = 15; // fewer than 64 bytes per chunk is stupid.\n// technically it could work with as few as 8, but even 64 bytes\n// is absurdly low.  Usually a MB or more is best.\n\nbinding.Z_MIN_CHUNK = 64;\nbinding.Z_MAX_CHUNK = Infinity;\nbinding.Z_DEFAULT_CHUNK = 16 * 1024;\nbinding.Z_MIN_MEMLEVEL = 1;\nbinding.Z_MAX_MEMLEVEL = 9;\nbinding.Z_DEFAULT_MEMLEVEL = 8;\nbinding.Z_MIN_LEVEL = -1;\nbinding.Z_MAX_LEVEL = 9;\nbinding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION; // expose all the zlib constants\n\nvar bkeys = Object.keys(binding);\n\nfor (var bk = 0; bk < bkeys.length; bk++) {\n  var bkey = bkeys[bk];\n\n  if (bkey.match(/^Z/)) {\n    Object.defineProperty(exports, bkey, {\n      enumerable: true,\n      value: binding[bkey],\n      writable: false\n    });\n  }\n} // translation table for return codes.\n\n\nvar codes = {\n  Z_OK: binding.Z_OK,\n  Z_STREAM_END: binding.Z_STREAM_END,\n  Z_NEED_DICT: binding.Z_NEED_DICT,\n  Z_ERRNO: binding.Z_ERRNO,\n  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,\n  Z_DATA_ERROR: binding.Z_DATA_ERROR,\n  Z_MEM_ERROR: binding.Z_MEM_ERROR,\n  Z_BUF_ERROR: binding.Z_BUF_ERROR,\n  Z_VERSION_ERROR: binding.Z_VERSION_ERROR\n};\nvar ckeys = Object.keys(codes);\n\nfor (var ck = 0; ck < ckeys.length; ck++) {\n  var ckey = ckeys[ck];\n  codes[codes[ckey]] = ckey;\n}\n\nObject.defineProperty(exports, 'codes', {\n  enumerable: true,\n  value: Object.freeze(codes),\n  writable: false\n});\nexports.Deflate = Deflate;\nexports.Inflate = Inflate;\nexports.Gzip = Gzip;\nexports.Gunzip = Gunzip;\nexports.DeflateRaw = DeflateRaw;\nexports.InflateRaw = InflateRaw;\nexports.Unzip = Unzip;\n\nexports.createDeflate = function (o) {\n  return new Deflate(o);\n};\n\nexports.createInflate = function (o) {\n  return new Inflate(o);\n};\n\nexports.createDeflateRaw = function (o) {\n  return new DeflateRaw(o);\n};\n\nexports.createInflateRaw = function (o) {\n  return new InflateRaw(o);\n};\n\nexports.createGzip = function (o) {\n  return new Gzip(o);\n};\n\nexports.createGunzip = function (o) {\n  return new Gunzip(o);\n};\n\nexports.createUnzip = function (o) {\n  return new Unzip(o);\n}; // Convenience methods.\n// compress/decompress a string or buffer in one step.\n\n\nexports.deflate = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  return zlibBuffer(new Deflate(opts), buffer, callback);\n};\n\nexports.deflateSync = function (buffer, opts) {\n  return zlibBufferSync(new Deflate(opts), buffer);\n};\n\nexports.gzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  return zlibBuffer(new Gzip(opts), buffer, callback);\n};\n\nexports.gzipSync = function (buffer, opts) {\n  return zlibBufferSync(new Gzip(opts), buffer);\n};\n\nexports.deflateRaw = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  return zlibBuffer(new DeflateRaw(opts), buffer, callback);\n};\n\nexports.deflateRawSync = function (buffer, opts) {\n  return zlibBufferSync(new DeflateRaw(opts), buffer);\n};\n\nexports.unzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  return zlibBuffer(new Unzip(opts), buffer, callback);\n};\n\nexports.unzipSync = function (buffer, opts) {\n  return zlibBufferSync(new Unzip(opts), buffer);\n};\n\nexports.inflate = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  return zlibBuffer(new Inflate(opts), buffer, callback);\n};\n\nexports.inflateSync = function (buffer, opts) {\n  return zlibBufferSync(new Inflate(opts), buffer);\n};\n\nexports.gunzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  return zlibBuffer(new Gunzip(opts), buffer, callback);\n};\n\nexports.gunzipSync = function (buffer, opts) {\n  return zlibBufferSync(new Gunzip(opts), buffer);\n};\n\nexports.inflateRaw = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  return zlibBuffer(new InflateRaw(opts), buffer, callback);\n};\n\nexports.inflateRawSync = function (buffer, opts) {\n  return zlibBufferSync(new InflateRaw(opts), buffer);\n};\n\nfunction zlibBuffer(engine, buffer, callback) {\n  var buffers = [];\n  var nread = 0;\n  engine.on('error', onError);\n  engine.on('end', onEnd);\n  engine.end(buffer);\n  flow();\n\n  function flow() {\n    var chunk;\n\n    while (null !== (chunk = engine.read())) {\n      buffers.push(chunk);\n      nread += chunk.length;\n    }\n\n    engine.once('readable', flow);\n  }\n\n  function onError(err) {\n    engine.removeListener('end', onEnd);\n    engine.removeListener('readable', flow);\n    callback(err);\n  }\n\n  function onEnd() {\n    var buf;\n    var err = null;\n\n    if (nread >= kMaxLength) {\n      err = new RangeError(kRangeErrorMessage);\n    } else {\n      buf = Buffer.concat(buffers, nread);\n    }\n\n    buffers = [];\n    engine.close();\n    callback(err, buf);\n  }\n}\n\nfunction zlibBufferSync(engine, buffer) {\n  if (typeof buffer === 'string') buffer = Buffer.from(buffer);\n  if (!Buffer.isBuffer(buffer)) throw new TypeError('Not a string or buffer');\n  var flushFlag = engine._finishFlushFlag;\n  return engine._processChunk(buffer, flushFlag);\n} // generic zlib\n// minimal 2-byte header\n\n\nfunction Deflate(opts) {\n  if (!(this instanceof Deflate)) return new Deflate(opts);\n  Zlib.call(this, opts, binding.DEFLATE);\n}\n\nfunction Inflate(opts) {\n  if (!(this instanceof Inflate)) return new Inflate(opts);\n  Zlib.call(this, opts, binding.INFLATE);\n} // gzip - bigger header, same deflate compression\n\n\nfunction Gzip(opts) {\n  if (!(this instanceof Gzip)) return new Gzip(opts);\n  Zlib.call(this, opts, binding.GZIP);\n}\n\nfunction Gunzip(opts) {\n  if (!(this instanceof Gunzip)) return new Gunzip(opts);\n  Zlib.call(this, opts, binding.GUNZIP);\n} // raw - no header\n\n\nfunction DeflateRaw(opts) {\n  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);\n  Zlib.call(this, opts, binding.DEFLATERAW);\n}\n\nfunction InflateRaw(opts) {\n  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);\n  Zlib.call(this, opts, binding.INFLATERAW);\n} // auto-detect header.\n\n\nfunction Unzip(opts) {\n  if (!(this instanceof Unzip)) return new Unzip(opts);\n  Zlib.call(this, opts, binding.UNZIP);\n}\n\nfunction isValidFlushFlag(flag) {\n  return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;\n} // the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\n\n\nfunction Zlib(opts, mode) {\n  var _this = this;\n\n  this._opts = opts = opts || {};\n  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;\n  Transform.call(this, opts);\n\n  if (opts.flush && !isValidFlushFlag(opts.flush)) {\n    throw new Error('Invalid flush flag: ' + opts.flush);\n  }\n\n  if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {\n    throw new Error('Invalid flush flag: ' + opts.finishFlush);\n  }\n\n  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;\n  this._finishFlushFlag = typeof opts.finishFlush !== 'undefined' ? opts.finishFlush : binding.Z_FINISH;\n\n  if (opts.chunkSize) {\n    if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {\n      throw new Error('Invalid chunk size: ' + opts.chunkSize);\n    }\n  }\n\n  if (opts.windowBits) {\n    if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {\n      throw new Error('Invalid windowBits: ' + opts.windowBits);\n    }\n  }\n\n  if (opts.level) {\n    if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {\n      throw new Error('Invalid compression level: ' + opts.level);\n    }\n  }\n\n  if (opts.memLevel) {\n    if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {\n      throw new Error('Invalid memLevel: ' + opts.memLevel);\n    }\n  }\n\n  if (opts.strategy) {\n    if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {\n      throw new Error('Invalid strategy: ' + opts.strategy);\n    }\n  }\n\n  if (opts.dictionary) {\n    if (!Buffer.isBuffer(opts.dictionary)) {\n      throw new Error('Invalid dictionary: it should be a Buffer instance');\n    }\n  }\n\n  this._handle = new binding.Zlib(mode);\n  var self = this;\n  this._hadError = false;\n\n  this._handle.onerror = function (message, errno) {\n    // there is no way to cleanly recover.\n    // continuing only obscures problems.\n    _close(self);\n\n    self._hadError = true;\n    var error = new Error(message);\n    error.errno = errno;\n    error.code = exports.codes[errno];\n    self.emit('error', error);\n  };\n\n  var level = exports.Z_DEFAULT_COMPRESSION;\n  if (typeof opts.level === 'number') level = opts.level;\n  var strategy = exports.Z_DEFAULT_STRATEGY;\n  if (typeof opts.strategy === 'number') strategy = opts.strategy;\n\n  this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);\n\n  this._buffer = Buffer.allocUnsafe(this._chunkSize);\n  this._offset = 0;\n  this._level = level;\n  this._strategy = strategy;\n  this.once('end', this.close);\n  Object.defineProperty(this, '_closed', {\n    get: function () {\n      return !_this._handle;\n    },\n    configurable: true,\n    enumerable: true\n  });\n}\n\nutil.inherits(Zlib, Transform);\n\nZlib.prototype.params = function (level, strategy, callback) {\n  if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {\n    throw new RangeError('Invalid compression level: ' + level);\n  }\n\n  if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {\n    throw new TypeError('Invalid strategy: ' + strategy);\n  }\n\n  if (this._level !== level || this._strategy !== strategy) {\n    var self = this;\n    this.flush(binding.Z_SYNC_FLUSH, function () {\n      assert(self._handle, 'zlib binding closed');\n\n      self._handle.params(level, strategy);\n\n      if (!self._hadError) {\n        self._level = level;\n        self._strategy = strategy;\n        if (callback) callback();\n      }\n    });\n  } else {\n    process.nextTick(callback);\n  }\n};\n\nZlib.prototype.reset = function () {\n  assert(this._handle, 'zlib binding closed');\n  return this._handle.reset();\n}; // This is the _flush function called by the transform class,\n// internally, when the last chunk has been written.\n\n\nZlib.prototype._flush = function (callback) {\n  this._transform(Buffer.alloc(0), '', callback);\n};\n\nZlib.prototype.flush = function (kind, callback) {\n  var _this2 = this;\n\n  var ws = this._writableState;\n\n  if (typeof kind === 'function' || kind === undefined && !callback) {\n    callback = kind;\n    kind = binding.Z_FULL_FLUSH;\n  }\n\n  if (ws.ended) {\n    if (callback) process.nextTick(callback);\n  } else if (ws.ending) {\n    if (callback) this.once('end', callback);\n  } else if (ws.needDrain) {\n    if (callback) {\n      this.once('drain', function () {\n        return _this2.flush(kind, callback);\n      });\n    }\n  } else {\n    this._flushFlag = kind;\n    this.write(Buffer.alloc(0), '', callback);\n  }\n};\n\nZlib.prototype.close = function (callback) {\n  _close(this, callback);\n\n  process.nextTick(emitCloseNT, this);\n};\n\nfunction _close(engine, callback) {\n  if (callback) process.nextTick(callback); // Caller may invoke .close after a zlib error (which will null _handle).\n\n  if (!engine._handle) return;\n\n  engine._handle.close();\n\n  engine._handle = null;\n}\n\nfunction emitCloseNT(self) {\n  self.emit('close');\n}\n\nZlib.prototype._transform = function (chunk, encoding, cb) {\n  var flushFlag;\n  var ws = this._writableState;\n  var ending = ws.ending || ws.ended;\n  var last = ending && (!chunk || ws.length === chunk.length);\n  if (chunk !== null && !Buffer.isBuffer(chunk)) return cb(new Error('invalid input'));\n  if (!this._handle) return cb(new Error('zlib binding closed')); // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag\n  // (or whatever flag was provided using opts.finishFlush).\n  // If it's explicitly flushing at some other time, then we use\n  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression\n  // goodness.\n\n  if (last) flushFlag = this._finishFlushFlag;else {\n    flushFlag = this._flushFlag; // once we've flushed the last of the queue, stop flushing and\n    // go back to the normal behavior.\n\n    if (chunk.length >= ws.length) {\n      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;\n    }\n  }\n\n  this._processChunk(chunk, flushFlag, cb);\n};\n\nZlib.prototype._processChunk = function (chunk, flushFlag, cb) {\n  var availInBefore = chunk && chunk.length;\n  var availOutBefore = this._chunkSize - this._offset;\n  var inOff = 0;\n  var self = this;\n  var async = typeof cb === 'function';\n\n  if (!async) {\n    var buffers = [];\n    var nread = 0;\n    var error;\n    this.on('error', function (er) {\n      error = er;\n    });\n    assert(this._handle, 'zlib binding closed');\n\n    do {\n      var res = this._handle.writeSync(flushFlag, chunk, // in\n      inOff, // in_off\n      availInBefore, // in_len\n      this._buffer, // out\n      this._offset, //out_off\n      availOutBefore); // out_len\n\n    } while (!this._hadError && callback(res[0], res[1]));\n\n    if (this._hadError) {\n      throw error;\n    }\n\n    if (nread >= kMaxLength) {\n      _close(this);\n\n      throw new RangeError(kRangeErrorMessage);\n    }\n\n    var buf = Buffer.concat(buffers, nread);\n\n    _close(this);\n\n    return buf;\n  }\n\n  assert(this._handle, 'zlib binding closed');\n\n  var req = this._handle.write(flushFlag, chunk, // in\n  inOff, // in_off\n  availInBefore, // in_len\n  this._buffer, // out\n  this._offset, //out_off\n  availOutBefore); // out_len\n\n\n  req.buffer = chunk;\n  req.callback = callback;\n\n  function callback(availInAfter, availOutAfter) {\n    // When the callback is used in an async write, the callback's\n    // context is the `req` object that was created. The req object\n    // is === this._handle, and that's why it's important to null\n    // out the values after they are done being used. `this._handle`\n    // can stay in memory longer than the callback and buffer are needed.\n    if (this) {\n      this.buffer = null;\n      this.callback = null;\n    }\n\n    if (self._hadError) return;\n    var have = availOutBefore - availOutAfter;\n    assert(have >= 0, 'have should not go down');\n\n    if (have > 0) {\n      var out = self._buffer.slice(self._offset, self._offset + have);\n\n      self._offset += have; // serve some output to the consumer.\n\n      if (async) {\n        self.push(out);\n      } else {\n        buffers.push(out);\n        nread += out.length;\n      }\n    } // exhausted the output buffer, or used all the input create a new one.\n\n\n    if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n      availOutBefore = self._chunkSize;\n      self._offset = 0;\n      self._buffer = Buffer.allocUnsafe(self._chunkSize);\n    }\n\n    if (availOutAfter === 0) {\n      // Not actually done.  Need to reprocess.\n      // Also, update the availInBefore to the availInAfter value,\n      // so that if we have to hit it a third (fourth, etc.) time,\n      // it'll have the correct byte counts.\n      inOff += availInBefore - availInAfter;\n      availInBefore = availInAfter;\n      if (!async) return true;\n\n      var newReq = self._handle.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);\n\n      newReq.callback = callback; // this same function\n\n      newReq.buffer = chunk;\n      return;\n    }\n\n    if (!async) return false; // finished with the chunk.\n\n    cb();\n  }\n};\n\nutil.inherits(Deflate, Zlib);\nutil.inherits(Inflate, Zlib);\nutil.inherits(Gzip, Zlib);\nutil.inherits(Gunzip, Zlib);\nutil.inherits(DeflateRaw, Zlib);\nutil.inherits(InflateRaw, Zlib);\nutil.inherits(Unzip, Zlib);","map":{"version":3,"sources":["/Users/allan.chepkoy/cloud/kubeflow/components/zoradashboard/node_modules/browserify-zlib/lib/index.js"],"names":["Buffer","require","Transform","binding","util","assert","ok","kMaxLength","kRangeErrorMessage","toString","Z_MIN_WINDOWBITS","Z_MAX_WINDOWBITS","Z_DEFAULT_WINDOWBITS","Z_MIN_CHUNK","Z_MAX_CHUNK","Infinity","Z_DEFAULT_CHUNK","Z_MIN_MEMLEVEL","Z_MAX_MEMLEVEL","Z_DEFAULT_MEMLEVEL","Z_MIN_LEVEL","Z_MAX_LEVEL","Z_DEFAULT_LEVEL","Z_DEFAULT_COMPRESSION","bkeys","Object","keys","bk","length","bkey","match","defineProperty","exports","enumerable","value","writable","codes","Z_OK","Z_STREAM_END","Z_NEED_DICT","Z_ERRNO","Z_STREAM_ERROR","Z_DATA_ERROR","Z_MEM_ERROR","Z_BUF_ERROR","Z_VERSION_ERROR","ckeys","ck","ckey","freeze","Deflate","Inflate","Gzip","Gunzip","DeflateRaw","InflateRaw","Unzip","createDeflate","o","createInflate","createDeflateRaw","createInflateRaw","createGzip","createGunzip","createUnzip","deflate","buffer","opts","callback","zlibBuffer","deflateSync","zlibBufferSync","gzip","gzipSync","deflateRaw","deflateRawSync","unzip","unzipSync","inflate","inflateSync","gunzip","gunzipSync","inflateRaw","inflateRawSync","engine","buffers","nread","on","onError","onEnd","end","flow","chunk","read","push","once","err","removeListener","buf","RangeError","concat","close","from","isBuffer","TypeError","flushFlag","_finishFlushFlag","_processChunk","Zlib","call","DEFLATE","INFLATE","GZIP","GUNZIP","DEFLATERAW","INFLATERAW","UNZIP","isValidFlushFlag","flag","Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_SYNC_FLUSH","Z_FULL_FLUSH","Z_FINISH","Z_BLOCK","mode","_this","_opts","_chunkSize","chunkSize","flush","Error","finishFlush","_flushFlag","windowBits","level","memLevel","strategy","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_FIXED","Z_DEFAULT_STRATEGY","dictionary","_handle","self","_hadError","onerror","message","errno","_close","error","code","emit","init","_buffer","allocUnsafe","_offset","_level","_strategy","get","configurable","inherits","prototype","params","process","nextTick","reset","_flush","_transform","alloc","kind","_this2","ws","_writableState","undefined","ended","ending","needDrain","write","emitCloseNT","encoding","cb","last","availInBefore","availOutBefore","inOff","async","er","res","writeSync","req","availInAfter","availOutAfter","have","out","slice","newReq"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Buffer = require('buffer').Buffer;\nvar Transform = require('stream').Transform;\nvar binding = require('./binding');\nvar util = require('util');\nvar assert = require('assert').ok;\nvar kMaxLength = require('buffer').kMaxLength;\nvar kRangeErrorMessage = 'Cannot create final Buffer. It would be larger ' + 'than 0x' + kMaxLength.toString(16) + ' bytes';\n\n// zlib doesn't provide these, so kludge them in following the same\n// const naming scheme zlib uses.\nbinding.Z_MIN_WINDOWBITS = 8;\nbinding.Z_MAX_WINDOWBITS = 15;\nbinding.Z_DEFAULT_WINDOWBITS = 15;\n\n// fewer than 64 bytes per chunk is stupid.\n// technically it could work with as few as 8, but even 64 bytes\n// is absurdly low.  Usually a MB or more is best.\nbinding.Z_MIN_CHUNK = 64;\nbinding.Z_MAX_CHUNK = Infinity;\nbinding.Z_DEFAULT_CHUNK = 16 * 1024;\n\nbinding.Z_MIN_MEMLEVEL = 1;\nbinding.Z_MAX_MEMLEVEL = 9;\nbinding.Z_DEFAULT_MEMLEVEL = 8;\n\nbinding.Z_MIN_LEVEL = -1;\nbinding.Z_MAX_LEVEL = 9;\nbinding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;\n\n// expose all the zlib constants\nvar bkeys = Object.keys(binding);\nfor (var bk = 0; bk < bkeys.length; bk++) {\n  var bkey = bkeys[bk];\n  if (bkey.match(/^Z/)) {\n    Object.defineProperty(exports, bkey, {\n      enumerable: true, value: binding[bkey], writable: false\n    });\n  }\n}\n\n// translation table for return codes.\nvar codes = {\n  Z_OK: binding.Z_OK,\n  Z_STREAM_END: binding.Z_STREAM_END,\n  Z_NEED_DICT: binding.Z_NEED_DICT,\n  Z_ERRNO: binding.Z_ERRNO,\n  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,\n  Z_DATA_ERROR: binding.Z_DATA_ERROR,\n  Z_MEM_ERROR: binding.Z_MEM_ERROR,\n  Z_BUF_ERROR: binding.Z_BUF_ERROR,\n  Z_VERSION_ERROR: binding.Z_VERSION_ERROR\n};\n\nvar ckeys = Object.keys(codes);\nfor (var ck = 0; ck < ckeys.length; ck++) {\n  var ckey = ckeys[ck];\n  codes[codes[ckey]] = ckey;\n}\n\nObject.defineProperty(exports, 'codes', {\n  enumerable: true, value: Object.freeze(codes), writable: false\n});\n\nexports.Deflate = Deflate;\nexports.Inflate = Inflate;\nexports.Gzip = Gzip;\nexports.Gunzip = Gunzip;\nexports.DeflateRaw = DeflateRaw;\nexports.InflateRaw = InflateRaw;\nexports.Unzip = Unzip;\n\nexports.createDeflate = function (o) {\n  return new Deflate(o);\n};\n\nexports.createInflate = function (o) {\n  return new Inflate(o);\n};\n\nexports.createDeflateRaw = function (o) {\n  return new DeflateRaw(o);\n};\n\nexports.createInflateRaw = function (o) {\n  return new InflateRaw(o);\n};\n\nexports.createGzip = function (o) {\n  return new Gzip(o);\n};\n\nexports.createGunzip = function (o) {\n  return new Gunzip(o);\n};\n\nexports.createUnzip = function (o) {\n  return new Unzip(o);\n};\n\n// Convenience methods.\n// compress/decompress a string or buffer in one step.\nexports.deflate = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Deflate(opts), buffer, callback);\n};\n\nexports.deflateSync = function (buffer, opts) {\n  return zlibBufferSync(new Deflate(opts), buffer);\n};\n\nexports.gzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Gzip(opts), buffer, callback);\n};\n\nexports.gzipSync = function (buffer, opts) {\n  return zlibBufferSync(new Gzip(opts), buffer);\n};\n\nexports.deflateRaw = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new DeflateRaw(opts), buffer, callback);\n};\n\nexports.deflateRawSync = function (buffer, opts) {\n  return zlibBufferSync(new DeflateRaw(opts), buffer);\n};\n\nexports.unzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Unzip(opts), buffer, callback);\n};\n\nexports.unzipSync = function (buffer, opts) {\n  return zlibBufferSync(new Unzip(opts), buffer);\n};\n\nexports.inflate = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Inflate(opts), buffer, callback);\n};\n\nexports.inflateSync = function (buffer, opts) {\n  return zlibBufferSync(new Inflate(opts), buffer);\n};\n\nexports.gunzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Gunzip(opts), buffer, callback);\n};\n\nexports.gunzipSync = function (buffer, opts) {\n  return zlibBufferSync(new Gunzip(opts), buffer);\n};\n\nexports.inflateRaw = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new InflateRaw(opts), buffer, callback);\n};\n\nexports.inflateRawSync = function (buffer, opts) {\n  return zlibBufferSync(new InflateRaw(opts), buffer);\n};\n\nfunction zlibBuffer(engine, buffer, callback) {\n  var buffers = [];\n  var nread = 0;\n\n  engine.on('error', onError);\n  engine.on('end', onEnd);\n\n  engine.end(buffer);\n  flow();\n\n  function flow() {\n    var chunk;\n    while (null !== (chunk = engine.read())) {\n      buffers.push(chunk);\n      nread += chunk.length;\n    }\n    engine.once('readable', flow);\n  }\n\n  function onError(err) {\n    engine.removeListener('end', onEnd);\n    engine.removeListener('readable', flow);\n    callback(err);\n  }\n\n  function onEnd() {\n    var buf;\n    var err = null;\n\n    if (nread >= kMaxLength) {\n      err = new RangeError(kRangeErrorMessage);\n    } else {\n      buf = Buffer.concat(buffers, nread);\n    }\n\n    buffers = [];\n    engine.close();\n    callback(err, buf);\n  }\n}\n\nfunction zlibBufferSync(engine, buffer) {\n  if (typeof buffer === 'string') buffer = Buffer.from(buffer);\n\n  if (!Buffer.isBuffer(buffer)) throw new TypeError('Not a string or buffer');\n\n  var flushFlag = engine._finishFlushFlag;\n\n  return engine._processChunk(buffer, flushFlag);\n}\n\n// generic zlib\n// minimal 2-byte header\nfunction Deflate(opts) {\n  if (!(this instanceof Deflate)) return new Deflate(opts);\n  Zlib.call(this, opts, binding.DEFLATE);\n}\n\nfunction Inflate(opts) {\n  if (!(this instanceof Inflate)) return new Inflate(opts);\n  Zlib.call(this, opts, binding.INFLATE);\n}\n\n// gzip - bigger header, same deflate compression\nfunction Gzip(opts) {\n  if (!(this instanceof Gzip)) return new Gzip(opts);\n  Zlib.call(this, opts, binding.GZIP);\n}\n\nfunction Gunzip(opts) {\n  if (!(this instanceof Gunzip)) return new Gunzip(opts);\n  Zlib.call(this, opts, binding.GUNZIP);\n}\n\n// raw - no header\nfunction DeflateRaw(opts) {\n  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);\n  Zlib.call(this, opts, binding.DEFLATERAW);\n}\n\nfunction InflateRaw(opts) {\n  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);\n  Zlib.call(this, opts, binding.INFLATERAW);\n}\n\n// auto-detect header.\nfunction Unzip(opts) {\n  if (!(this instanceof Unzip)) return new Unzip(opts);\n  Zlib.call(this, opts, binding.UNZIP);\n}\n\nfunction isValidFlushFlag(flag) {\n  return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;\n}\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\n\nfunction Zlib(opts, mode) {\n  var _this = this;\n\n  this._opts = opts = opts || {};\n  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;\n\n  Transform.call(this, opts);\n\n  if (opts.flush && !isValidFlushFlag(opts.flush)) {\n    throw new Error('Invalid flush flag: ' + opts.flush);\n  }\n  if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {\n    throw new Error('Invalid flush flag: ' + opts.finishFlush);\n  }\n\n  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;\n  this._finishFlushFlag = typeof opts.finishFlush !== 'undefined' ? opts.finishFlush : binding.Z_FINISH;\n\n  if (opts.chunkSize) {\n    if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {\n      throw new Error('Invalid chunk size: ' + opts.chunkSize);\n    }\n  }\n\n  if (opts.windowBits) {\n    if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {\n      throw new Error('Invalid windowBits: ' + opts.windowBits);\n    }\n  }\n\n  if (opts.level) {\n    if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {\n      throw new Error('Invalid compression level: ' + opts.level);\n    }\n  }\n\n  if (opts.memLevel) {\n    if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {\n      throw new Error('Invalid memLevel: ' + opts.memLevel);\n    }\n  }\n\n  if (opts.strategy) {\n    if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {\n      throw new Error('Invalid strategy: ' + opts.strategy);\n    }\n  }\n\n  if (opts.dictionary) {\n    if (!Buffer.isBuffer(opts.dictionary)) {\n      throw new Error('Invalid dictionary: it should be a Buffer instance');\n    }\n  }\n\n  this._handle = new binding.Zlib(mode);\n\n  var self = this;\n  this._hadError = false;\n  this._handle.onerror = function (message, errno) {\n    // there is no way to cleanly recover.\n    // continuing only obscures problems.\n    _close(self);\n    self._hadError = true;\n\n    var error = new Error(message);\n    error.errno = errno;\n    error.code = exports.codes[errno];\n    self.emit('error', error);\n  };\n\n  var level = exports.Z_DEFAULT_COMPRESSION;\n  if (typeof opts.level === 'number') level = opts.level;\n\n  var strategy = exports.Z_DEFAULT_STRATEGY;\n  if (typeof opts.strategy === 'number') strategy = opts.strategy;\n\n  this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);\n\n  this._buffer = Buffer.allocUnsafe(this._chunkSize);\n  this._offset = 0;\n  this._level = level;\n  this._strategy = strategy;\n\n  this.once('end', this.close);\n\n  Object.defineProperty(this, '_closed', {\n    get: function () {\n      return !_this._handle;\n    },\n    configurable: true,\n    enumerable: true\n  });\n}\n\nutil.inherits(Zlib, Transform);\n\nZlib.prototype.params = function (level, strategy, callback) {\n  if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {\n    throw new RangeError('Invalid compression level: ' + level);\n  }\n  if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {\n    throw new TypeError('Invalid strategy: ' + strategy);\n  }\n\n  if (this._level !== level || this._strategy !== strategy) {\n    var self = this;\n    this.flush(binding.Z_SYNC_FLUSH, function () {\n      assert(self._handle, 'zlib binding closed');\n      self._handle.params(level, strategy);\n      if (!self._hadError) {\n        self._level = level;\n        self._strategy = strategy;\n        if (callback) callback();\n      }\n    });\n  } else {\n    process.nextTick(callback);\n  }\n};\n\nZlib.prototype.reset = function () {\n  assert(this._handle, 'zlib binding closed');\n  return this._handle.reset();\n};\n\n// This is the _flush function called by the transform class,\n// internally, when the last chunk has been written.\nZlib.prototype._flush = function (callback) {\n  this._transform(Buffer.alloc(0), '', callback);\n};\n\nZlib.prototype.flush = function (kind, callback) {\n  var _this2 = this;\n\n  var ws = this._writableState;\n\n  if (typeof kind === 'function' || kind === undefined && !callback) {\n    callback = kind;\n    kind = binding.Z_FULL_FLUSH;\n  }\n\n  if (ws.ended) {\n    if (callback) process.nextTick(callback);\n  } else if (ws.ending) {\n    if (callback) this.once('end', callback);\n  } else if (ws.needDrain) {\n    if (callback) {\n      this.once('drain', function () {\n        return _this2.flush(kind, callback);\n      });\n    }\n  } else {\n    this._flushFlag = kind;\n    this.write(Buffer.alloc(0), '', callback);\n  }\n};\n\nZlib.prototype.close = function (callback) {\n  _close(this, callback);\n  process.nextTick(emitCloseNT, this);\n};\n\nfunction _close(engine, callback) {\n  if (callback) process.nextTick(callback);\n\n  // Caller may invoke .close after a zlib error (which will null _handle).\n  if (!engine._handle) return;\n\n  engine._handle.close();\n  engine._handle = null;\n}\n\nfunction emitCloseNT(self) {\n  self.emit('close');\n}\n\nZlib.prototype._transform = function (chunk, encoding, cb) {\n  var flushFlag;\n  var ws = this._writableState;\n  var ending = ws.ending || ws.ended;\n  var last = ending && (!chunk || ws.length === chunk.length);\n\n  if (chunk !== null && !Buffer.isBuffer(chunk)) return cb(new Error('invalid input'));\n\n  if (!this._handle) return cb(new Error('zlib binding closed'));\n\n  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag\n  // (or whatever flag was provided using opts.finishFlush).\n  // If it's explicitly flushing at some other time, then we use\n  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression\n  // goodness.\n  if (last) flushFlag = this._finishFlushFlag;else {\n    flushFlag = this._flushFlag;\n    // once we've flushed the last of the queue, stop flushing and\n    // go back to the normal behavior.\n    if (chunk.length >= ws.length) {\n      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;\n    }\n  }\n\n  this._processChunk(chunk, flushFlag, cb);\n};\n\nZlib.prototype._processChunk = function (chunk, flushFlag, cb) {\n  var availInBefore = chunk && chunk.length;\n  var availOutBefore = this._chunkSize - this._offset;\n  var inOff = 0;\n\n  var self = this;\n\n  var async = typeof cb === 'function';\n\n  if (!async) {\n    var buffers = [];\n    var nread = 0;\n\n    var error;\n    this.on('error', function (er) {\n      error = er;\n    });\n\n    assert(this._handle, 'zlib binding closed');\n    do {\n      var res = this._handle.writeSync(flushFlag, chunk, // in\n      inOff, // in_off\n      availInBefore, // in_len\n      this._buffer, // out\n      this._offset, //out_off\n      availOutBefore); // out_len\n    } while (!this._hadError && callback(res[0], res[1]));\n\n    if (this._hadError) {\n      throw error;\n    }\n\n    if (nread >= kMaxLength) {\n      _close(this);\n      throw new RangeError(kRangeErrorMessage);\n    }\n\n    var buf = Buffer.concat(buffers, nread);\n    _close(this);\n\n    return buf;\n  }\n\n  assert(this._handle, 'zlib binding closed');\n  var req = this._handle.write(flushFlag, chunk, // in\n  inOff, // in_off\n  availInBefore, // in_len\n  this._buffer, // out\n  this._offset, //out_off\n  availOutBefore); // out_len\n\n  req.buffer = chunk;\n  req.callback = callback;\n\n  function callback(availInAfter, availOutAfter) {\n    // When the callback is used in an async write, the callback's\n    // context is the `req` object that was created. The req object\n    // is === this._handle, and that's why it's important to null\n    // out the values after they are done being used. `this._handle`\n    // can stay in memory longer than the callback and buffer are needed.\n    if (this) {\n      this.buffer = null;\n      this.callback = null;\n    }\n\n    if (self._hadError) return;\n\n    var have = availOutBefore - availOutAfter;\n    assert(have >= 0, 'have should not go down');\n\n    if (have > 0) {\n      var out = self._buffer.slice(self._offset, self._offset + have);\n      self._offset += have;\n      // serve some output to the consumer.\n      if (async) {\n        self.push(out);\n      } else {\n        buffers.push(out);\n        nread += out.length;\n      }\n    }\n\n    // exhausted the output buffer, or used all the input create a new one.\n    if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n      availOutBefore = self._chunkSize;\n      self._offset = 0;\n      self._buffer = Buffer.allocUnsafe(self._chunkSize);\n    }\n\n    if (availOutAfter === 0) {\n      // Not actually done.  Need to reprocess.\n      // Also, update the availInBefore to the availInAfter value,\n      // so that if we have to hit it a third (fourth, etc.) time,\n      // it'll have the correct byte counts.\n      inOff += availInBefore - availInAfter;\n      availInBefore = availInAfter;\n\n      if (!async) return true;\n\n      var newReq = self._handle.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);\n      newReq.callback = callback; // this same function\n      newReq.buffer = chunk;\n      return;\n    }\n\n    if (!async) return false;\n\n    // finished with the chunk.\n    cb();\n  }\n};\n\nutil.inherits(Deflate, Zlib);\nutil.inherits(Inflate, Zlib);\nutil.inherits(Gzip, Zlib);\nutil.inherits(Gunzip, Zlib);\nutil.inherits(DeflateRaw, Zlib);\nutil.inherits(InflateRaw, Zlib);\nutil.inherits(Unzip, Zlib);"]},"metadata":{},"sourceType":"script"}