{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n/* eslint-disable no-multi-assign */\n\nvar KASHIDA_PRIORITY = 0;\nvar NULL_PRIORITY = 3;\n\nvar getDistances = function getDistances(gap, factors) {\n  var total = 0;\n  var priorities = [];\n  var unconstrained = [];\n\n  for (var _priority = KASHIDA_PRIORITY; _priority <= NULL_PRIORITY; _priority += 1) {\n    priorities[_priority] = unconstrained[_priority] = 0;\n  } // sum the factors at each priority\n\n\n  for (var j = 0; j < factors.length; j += 1) {\n    var f = factors[j];\n    var sum = f.before + f.after;\n    total += sum;\n    priorities[f.priority] += sum;\n\n    if (f.unconstrained) {\n      unconstrained[f.priority] += sum;\n    }\n  } // choose the priorities that need to be applied\n\n\n  var highestPriority = -1;\n  var highestPrioritySum = 0;\n  var remainingGap = gap;\n  var priority;\n\n  for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\n    var prioritySum = priorities[priority];\n\n    if (prioritySum !== 0) {\n      if (highestPriority === -1) {\n        highestPriority = priority;\n        highestPrioritySum = prioritySum;\n      } // if this priority covers the remaining gap, we're done\n\n\n      if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {\n        priorities[priority] = remainingGap / prioritySum;\n        unconstrained[priority] = 0;\n        remainingGap = 0;\n        break;\n      } // mark that we need to use 100% of the adjustment from\n      // this priority, and subtract the space that it consumes\n\n\n      priorities[priority] = 1;\n      remainingGap -= prioritySum; // if this priority has unconstrained glyphs, let them consume the remaining space\n\n      if (unconstrained[priority] !== 0) {\n        unconstrained[priority] = remainingGap / unconstrained[priority];\n        remainingGap = 0;\n        break;\n      }\n    }\n  } // zero out remaining priorities (if any)\n\n\n  for (var p = priority + 1; p <= NULL_PRIORITY; p += 1) {\n    priorities[p] = 0;\n    unconstrained[p] = 0;\n  } // if there is still space left over, assign it to the highest priority that we saw.\n  // this violates their factors, but it only happens in extreme cases\n\n\n  if (remainingGap > 0 && highestPriority > -1) {\n    priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;\n  } // create and return an array of distances to add to each glyph's advance\n\n\n  var distances = [];\n\n  for (var index = 0; index < factors.length; index += 1) {\n    // the distance to add to this glyph is the sum of the space to add\n    // after this glyph, and the space to add before the next glyph\n    var _f = factors[index];\n    var next = factors[index + 1];\n    var dist = _f.after * priorities[_f.priority];\n\n    if (next) {\n      dist += next.before * priorities[next.priority];\n    } // if this glyph is unconstrained, add the unconstrained distance as well\n\n\n    if (_f.unconstrained) {\n      dist += _f.after * unconstrained[_f.priority];\n\n      if (next) {\n        dist += next.before * unconstrained[next.priority];\n      }\n    }\n\n    distances.push(dist);\n  }\n\n  return distances;\n};\n\nvar _default = getDistances;\nexports.default = _default;","map":{"version":3,"sources":["/Users/allan.chepkoy/cloud/kubeflow/components/zoradashboard/node_modules/@react-pdf/textkit/lib/engines/justification/getDistances.js"],"names":["exports","__esModule","default","KASHIDA_PRIORITY","NULL_PRIORITY","getDistances","gap","factors","total","priorities","unconstrained","_priority","j","length","f","sum","before","after","priority","highestPriority","highestPrioritySum","remainingGap","prioritySum","Math","abs","p","distances","index","_f","next","dist","push","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\n/* eslint-disable no-multi-assign */\nvar KASHIDA_PRIORITY = 0;\nvar NULL_PRIORITY = 3;\n\nvar getDistances = function getDistances(gap, factors) {\n  var total = 0;\n  var priorities = [];\n  var unconstrained = [];\n\n  for (var _priority = KASHIDA_PRIORITY; _priority <= NULL_PRIORITY; _priority += 1) {\n    priorities[_priority] = unconstrained[_priority] = 0;\n  } // sum the factors at each priority\n\n\n  for (var j = 0; j < factors.length; j += 1) {\n    var f = factors[j];\n    var sum = f.before + f.after;\n    total += sum;\n    priorities[f.priority] += sum;\n\n    if (f.unconstrained) {\n      unconstrained[f.priority] += sum;\n    }\n  } // choose the priorities that need to be applied\n\n\n  var highestPriority = -1;\n  var highestPrioritySum = 0;\n  var remainingGap = gap;\n  var priority;\n\n  for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\n    var prioritySum = priorities[priority];\n\n    if (prioritySum !== 0) {\n      if (highestPriority === -1) {\n        highestPriority = priority;\n        highestPrioritySum = prioritySum;\n      } // if this priority covers the remaining gap, we're done\n\n\n      if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {\n        priorities[priority] = remainingGap / prioritySum;\n        unconstrained[priority] = 0;\n        remainingGap = 0;\n        break;\n      } // mark that we need to use 100% of the adjustment from\n      // this priority, and subtract the space that it consumes\n\n\n      priorities[priority] = 1;\n      remainingGap -= prioritySum; // if this priority has unconstrained glyphs, let them consume the remaining space\n\n      if (unconstrained[priority] !== 0) {\n        unconstrained[priority] = remainingGap / unconstrained[priority];\n        remainingGap = 0;\n        break;\n      }\n    }\n  } // zero out remaining priorities (if any)\n\n\n  for (var p = priority + 1; p <= NULL_PRIORITY; p += 1) {\n    priorities[p] = 0;\n    unconstrained[p] = 0;\n  } // if there is still space left over, assign it to the highest priority that we saw.\n  // this violates their factors, but it only happens in extreme cases\n\n\n  if (remainingGap > 0 && highestPriority > -1) {\n    priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;\n  } // create and return an array of distances to add to each glyph's advance\n\n\n  var distances = [];\n\n  for (var index = 0; index < factors.length; index += 1) {\n    // the distance to add to this glyph is the sum of the space to add\n    // after this glyph, and the space to add before the next glyph\n    var _f = factors[index];\n    var next = factors[index + 1];\n    var dist = _f.after * priorities[_f.priority];\n\n    if (next) {\n      dist += next.before * priorities[next.priority];\n    } // if this glyph is unconstrained, add the unconstrained distance as well\n\n\n    if (_f.unconstrained) {\n      dist += _f.after * unconstrained[_f.priority];\n\n      if (next) {\n        dist += next.before * unconstrained[next.priority];\n      }\n    }\n\n    distances.push(dist);\n  }\n\n  return distances;\n};\n\nvar _default = getDistances;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}