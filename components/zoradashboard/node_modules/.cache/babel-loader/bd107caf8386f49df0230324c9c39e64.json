{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = exports.embedEmojis = exports.fetchEmojis = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _emojiRegex = _interopRequireDefault(require(\"emoji-regex\"));\n\nvar _image = _interopRequireDefault(require(\"@react-pdf/image\"));\n/* eslint-disable no-cond-assign */\n// Caches emoji images data\n\n\nvar emojis = {};\nvar regex = (0, _emojiRegex.default)();\n\nvar reflect = function reflect(promise) {\n  return function () {\n    return promise.apply(void 0, arguments).then(function (v) {\n      return v;\n    }, function (e) {\n      return e;\n    });\n  };\n}; // Returns a function to be able to mock resolveImage.\n\n\nvar makeFetchEmojiImage = function makeFetchEmojiImage() {\n  return reflect(_image.default);\n};\n/**\n * When an emoji as no color, it might still have 2 parts,\n * the canonical emoji and an empty string.\n * ex.\n *   (no color) Array.from('‚ù§Ô∏è') => [\"‚ù§\", \"Ô∏è\"]\n *   (w/ color) Array.from('üëçüèø') => [\"üëç\", \"üèø\"]\n *\n * The empty string needs to be removed otherwise the generated\n * url will be incorect.\n */\n\n\nvar _removeNoColor = function _removeNoColor(x) {\n  return x !== 'Ô∏è';\n};\n\nvar getCodePoints = function getCodePoints(string) {\n  return Array.from(string).filter(_removeNoColor).map(function (char) {\n    return char.codePointAt(0).toString(16);\n  }).join('-');\n};\n\nvar buildEmojiUrl = function buildEmojiUrl(emoji, source) {\n  var url = source.url,\n      format = source.format;\n  return \"\" + url + getCodePoints(emoji) + \".\" + format;\n};\n\nvar fetchEmojis = function fetchEmojis(string, source) {\n  if (!source || !source.url) return [];\n  var promises = [];\n  var match;\n\n  var _loop = function _loop() {\n    var emoji = match[0];\n\n    if (!emojis[emoji] || emojis[emoji].loading) {\n      var emojiUrl = buildEmojiUrl(emoji, source);\n      emojis[emoji] = {\n        loading: true\n      };\n      var fetchEmojiImage = makeFetchEmojiImage();\n      promises.push(fetchEmojiImage({\n        uri: emojiUrl\n      }).then(function (image) {\n        emojis[emoji].loading = false;\n        emojis[emoji].data = image.data;\n      }));\n    }\n  };\n\n  while (match = regex.exec(string)) {\n    _loop();\n  }\n\n  return promises;\n};\n\nexports.fetchEmojis = fetchEmojis;\n\nvar embedEmojis = function embedEmojis(fragments) {\n  var result = [];\n\n  for (var i = 0; i < fragments.length; i += 1) {\n    var fragment = fragments[i];\n    var match = void 0;\n    var lastIndex = 0;\n\n    while (match = regex.exec(fragment.string)) {\n      var _match = match,\n          index = _match.index;\n      var emoji = match[0];\n      var emojiSize = fragment.attributes.fontSize;\n      var chunk = fragment.string.slice(lastIndex, index + match[0].length); // If emoji image was found, we create a new fragment with the\n      // correct attachment and object substitution character;\n\n      if (emojis[emoji] && emojis[emoji].data) {\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0xfffc)),\n          attributes: (0, _extends2.default)({}, fragment.attributes, {\n            attachment: {\n              width: emojiSize,\n              height: emojiSize,\n              yOffset: Math.floor(emojiSize * 0.1),\n              image: emojis[emoji].data\n            }\n          })\n        });\n      } else {\n        // If no emoji data, we just replace the emoji with a nodef char\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0)),\n          attributes: fragment.attributes\n        });\n      }\n\n      lastIndex = index + emoji.length;\n    }\n\n    if (lastIndex < fragment.string.length) {\n      result.push({\n        string: fragment.string.slice(lastIndex),\n        attributes: fragment.attributes\n      });\n    }\n  }\n\n  return result;\n};\n\nexports.embedEmojis = embedEmojis;\nvar _default = fetchEmojis;\nexports.default = _default;","map":{"version":3,"sources":["/Users/allan.chepkoy/cloud/kubeflow/components/zoradashboard/node_modules/@react-pdf/layout/lib/text/emoji.js"],"names":["_interopRequireDefault","require","exports","__esModule","default","embedEmojis","fetchEmojis","_extends2","_emojiRegex","_image","emojis","regex","reflect","promise","apply","arguments","then","v","e","makeFetchEmojiImage","_removeNoColor","x","getCodePoints","string","Array","from","filter","map","char","codePointAt","toString","join","buildEmojiUrl","emoji","source","url","format","promises","match","_loop","loading","emojiUrl","fetchEmojiImage","push","uri","image","data","exec","fragments","result","i","length","fragment","lastIndex","_match","index","emojiSize","attributes","fontSize","chunk","slice","replace","String","fromCharCode","attachment","width","height","yOffset","Math","floor","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.default = exports.embedEmojis = exports.fetchEmojis = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _emojiRegex = _interopRequireDefault(require(\"emoji-regex\"));\n\nvar _image = _interopRequireDefault(require(\"@react-pdf/image\"));\n\n/* eslint-disable no-cond-assign */\n// Caches emoji images data\nvar emojis = {};\nvar regex = (0, _emojiRegex.default)();\n\nvar reflect = function reflect(promise) {\n  return function () {\n    return promise.apply(void 0, arguments).then(function (v) {\n      return v;\n    }, function (e) {\n      return e;\n    });\n  };\n}; // Returns a function to be able to mock resolveImage.\n\n\nvar makeFetchEmojiImage = function makeFetchEmojiImage() {\n  return reflect(_image.default);\n};\n/**\n * When an emoji as no color, it might still have 2 parts,\n * the canonical emoji and an empty string.\n * ex.\n *   (no color) Array.from('‚ù§Ô∏è') => [\"‚ù§\", \"Ô∏è\"]\n *   (w/ color) Array.from('üëçüèø') => [\"üëç\", \"üèø\"]\n *\n * The empty string needs to be removed otherwise the generated\n * url will be incorect.\n */\n\n\nvar _removeNoColor = function _removeNoColor(x) {\n  return x !== 'Ô∏è';\n};\n\nvar getCodePoints = function getCodePoints(string) {\n  return Array.from(string).filter(_removeNoColor).map(function (char) {\n    return char.codePointAt(0).toString(16);\n  }).join('-');\n};\n\nvar buildEmojiUrl = function buildEmojiUrl(emoji, source) {\n  var url = source.url,\n      format = source.format;\n  return \"\" + url + getCodePoints(emoji) + \".\" + format;\n};\n\nvar fetchEmojis = function fetchEmojis(string, source) {\n  if (!source || !source.url) return [];\n  var promises = [];\n  var match;\n\n  var _loop = function _loop() {\n    var emoji = match[0];\n\n    if (!emojis[emoji] || emojis[emoji].loading) {\n      var emojiUrl = buildEmojiUrl(emoji, source);\n      emojis[emoji] = {\n        loading: true\n      };\n      var fetchEmojiImage = makeFetchEmojiImage();\n      promises.push(fetchEmojiImage({\n        uri: emojiUrl\n      }).then(function (image) {\n        emojis[emoji].loading = false;\n        emojis[emoji].data = image.data;\n      }));\n    }\n  };\n\n  while (match = regex.exec(string)) {\n    _loop();\n  }\n\n  return promises;\n};\n\nexports.fetchEmojis = fetchEmojis;\n\nvar embedEmojis = function embedEmojis(fragments) {\n  var result = [];\n\n  for (var i = 0; i < fragments.length; i += 1) {\n    var fragment = fragments[i];\n    var match = void 0;\n    var lastIndex = 0;\n\n    while (match = regex.exec(fragment.string)) {\n      var _match = match,\n          index = _match.index;\n      var emoji = match[0];\n      var emojiSize = fragment.attributes.fontSize;\n      var chunk = fragment.string.slice(lastIndex, index + match[0].length); // If emoji image was found, we create a new fragment with the\n      // correct attachment and object substitution character;\n\n      if (emojis[emoji] && emojis[emoji].data) {\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0xfffc)),\n          attributes: (0, _extends2.default)({}, fragment.attributes, {\n            attachment: {\n              width: emojiSize,\n              height: emojiSize,\n              yOffset: Math.floor(emojiSize * 0.1),\n              image: emojis[emoji].data\n            }\n          })\n        });\n      } else {\n        // If no emoji data, we just replace the emoji with a nodef char\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0)),\n          attributes: fragment.attributes\n        });\n      }\n\n      lastIndex = index + emoji.length;\n    }\n\n    if (lastIndex < fragment.string.length) {\n      result.push({\n        string: fragment.string.slice(lastIndex),\n        attributes: fragment.attributes\n      });\n    }\n  }\n\n  return result;\n};\n\nexports.embedEmojis = embedEmojis;\nvar _default = fetchEmojis;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}