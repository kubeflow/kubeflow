{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\")); // TODO: Implement using only matrices to support skew and even more operations than css.\n\n\nvar applySingleTransformation = function applySingleTransformation(ctx, transform, origin) {\n  var operation = transform.operation,\n      value = transform.value;\n\n  switch (operation) {\n    case 'scale':\n      {\n        var scaleX = value[0],\n            scaleY = value[1];\n        ctx.scale(scaleX, scaleY, {\n          origin: origin\n        });\n        break;\n      }\n\n    case 'rotate':\n      {\n        var angle = value[0];\n        ctx.rotate(angle, {\n          origin: origin\n        });\n        break;\n      }\n\n    case 'translate':\n      {\n        var x = value[0],\n            y = value[1];\n        ctx.translate(x, y, {\n          origin: origin\n        });\n        break;\n      }\n\n    case 'matrix':\n      {\n        ctx.transform.apply(ctx, value);\n        break;\n      }\n\n    default:\n      {\n        console.error(\"Transform operation: '\" + operation + \"' doesn't supported\");\n      }\n  }\n};\n\nvar applyTransformations = function applyTransformations(ctx, node) {\n  if (!node.origin) return node;\n  var origin = [node.origin.left, node.origin.top];\n  var operations = node.style && node.style.transform || [];\n  operations.forEach(function (operation) {\n    applySingleTransformation(ctx, operation, origin);\n  });\n  return node;\n};\n\nvar _default = R.curryN(2, applyTransformations);\n\nexports.default = _default;","map":{"version":3,"sources":["/Users/allan.chepkoy/cloud/kubeflow/components/zoradashboard/node_modules/@react-pdf/render/lib/operations/transform.js"],"names":["_interopRequireWildcard","require","exports","__esModule","default","R","applySingleTransformation","ctx","transform","origin","operation","value","scaleX","scaleY","scale","angle","rotate","x","y","translate","apply","console","error","applyTransformations","node","left","top","operations","style","forEach","_default","curryN"],"mappings":"AAAA;;AAEA,IAAIA,uBAAuB,GAAGC,OAAO,CAAC,+CAAD,CAArC;;AAEAC,OAAO,CAACC,UAAR,GAAqB,IAArB;AACAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AAEA,IAAIC,CAAC,GAAGL,uBAAuB,CAACC,OAAO,CAAC,OAAD,CAAR,CAA/B,C,CAEA;;;AACA,IAAIK,yBAAyB,GAAG,SAASA,yBAAT,CAAmCC,GAAnC,EAAwCC,SAAxC,EAAmDC,MAAnD,EAA2D;AACzF,MAAIC,SAAS,GAAGF,SAAS,CAACE,SAA1B;AAAA,MACIC,KAAK,GAAGH,SAAS,CAACG,KADtB;;AAGA,UAAQD,SAAR;AACE,SAAK,OAAL;AACE;AACE,YAAIE,MAAM,GAAGD,KAAK,CAAC,CAAD,CAAlB;AAAA,YACIE,MAAM,GAAGF,KAAK,CAAC,CAAD,CADlB;AAEAJ,QAAAA,GAAG,CAACO,KAAJ,CAAUF,MAAV,EAAkBC,MAAlB,EAA0B;AACxBJ,UAAAA,MAAM,EAAEA;AADgB,SAA1B;AAGA;AACD;;AAEH,SAAK,QAAL;AACE;AACE,YAAIM,KAAK,GAAGJ,KAAK,CAAC,CAAD,CAAjB;AACAJ,QAAAA,GAAG,CAACS,MAAJ,CAAWD,KAAX,EAAkB;AAChBN,UAAAA,MAAM,EAAEA;AADQ,SAAlB;AAGA;AACD;;AAEH,SAAK,WAAL;AACE;AACE,YAAIQ,CAAC,GAAGN,KAAK,CAAC,CAAD,CAAb;AAAA,YACIO,CAAC,GAAGP,KAAK,CAAC,CAAD,CADb;AAEAJ,QAAAA,GAAG,CAACY,SAAJ,CAAcF,CAAd,EAAiBC,CAAjB,EAAoB;AAClBT,UAAAA,MAAM,EAAEA;AADU,SAApB;AAGA;AACD;;AAEH,SAAK,QAAL;AACE;AACEF,QAAAA,GAAG,CAACC,SAAJ,CAAcY,KAAd,CAAoBb,GAApB,EAAyBI,KAAzB;AACA;AACD;;AAEH;AACE;AACEU,QAAAA,OAAO,CAACC,KAAR,CAAc,2BAA2BZ,SAA3B,GAAuC,qBAArD;AACD;AAvCL;AAyCD,CA7CD;;AA+CA,IAAIa,oBAAoB,GAAG,SAASA,oBAAT,CAA8BhB,GAA9B,EAAmCiB,IAAnC,EAAyC;AAClE,MAAI,CAACA,IAAI,CAACf,MAAV,EAAkB,OAAOe,IAAP;AAClB,MAAIf,MAAM,GAAG,CAACe,IAAI,CAACf,MAAL,CAAYgB,IAAb,EAAmBD,IAAI,CAACf,MAAL,CAAYiB,GAA/B,CAAb;AACA,MAAIC,UAAU,GAAGH,IAAI,CAACI,KAAL,IAAcJ,IAAI,CAACI,KAAL,CAAWpB,SAAzB,IAAsC,EAAvD;AACAmB,EAAAA,UAAU,CAACE,OAAX,CAAmB,UAAUnB,SAAV,EAAqB;AACtCJ,IAAAA,yBAAyB,CAACC,GAAD,EAAMG,SAAN,EAAiBD,MAAjB,CAAzB;AACD,GAFD;AAGA,SAAOe,IAAP;AACD,CARD;;AAUA,IAAIM,QAAQ,GAAGzB,CAAC,CAAC0B,MAAF,CAAS,CAAT,EAAYR,oBAAZ,CAAf;;AAEArB,OAAO,CAACE,OAAR,GAAkB0B,QAAlB","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\n// TODO: Implement using only matrices to support skew and even more operations than css.\nvar applySingleTransformation = function applySingleTransformation(ctx, transform, origin) {\n  var operation = transform.operation,\n      value = transform.value;\n\n  switch (operation) {\n    case 'scale':\n      {\n        var scaleX = value[0],\n            scaleY = value[1];\n        ctx.scale(scaleX, scaleY, {\n          origin: origin\n        });\n        break;\n      }\n\n    case 'rotate':\n      {\n        var angle = value[0];\n        ctx.rotate(angle, {\n          origin: origin\n        });\n        break;\n      }\n\n    case 'translate':\n      {\n        var x = value[0],\n            y = value[1];\n        ctx.translate(x, y, {\n          origin: origin\n        });\n        break;\n      }\n\n    case 'matrix':\n      {\n        ctx.transform.apply(ctx, value);\n        break;\n      }\n\n    default:\n      {\n        console.error(\"Transform operation: '\" + operation + \"' doesn't supported\");\n      }\n  }\n};\n\nvar applyTransformations = function applyTransformations(ctx, node) {\n  if (!node.origin) return node;\n  var origin = [node.origin.left, node.origin.top];\n  var operations = node.style && node.style.transform || [];\n  operations.forEach(function (operation) {\n    applySingleTransformation(ctx, operation, origin);\n  });\n  return node;\n};\n\nvar _default = R.curryN(2, applyTransformations);\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}