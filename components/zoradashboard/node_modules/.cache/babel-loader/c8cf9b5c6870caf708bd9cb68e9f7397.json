{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js');\n\nvar factorySpace = require('../tokenize/factory-space.js');\n\nvar partialBlankLine = require('../tokenize/partial-blank-line.js');\n\nvar tokenize = initializeDocument;\nvar containerConstruct = {\n  tokenize: tokenizeContainer\n};\nvar lazyFlowConstruct = {\n  tokenize: tokenizeLazyFlow\n};\n\nfunction initializeDocument(effects) {\n  var self = this;\n  var stack = [];\n  var continued = 0;\n  var inspectConstruct = {\n    tokenize: tokenizeInspect,\n    partial: true\n  };\n  var inspectResult;\n  var childFlow;\n  var childToken;\n  return start;\n\n  function start(code) {\n    if (continued < stack.length) {\n      self.containerState = stack[continued][1];\n      return effects.attempt(stack[continued][0].continuation, documentContinue, documentContinued)(code);\n    }\n\n    return documentContinued(code);\n  }\n\n  function documentContinue(code) {\n    continued++;\n    return start(code);\n  }\n\n  function documentContinued(code) {\n    // If we’re in a concrete construct (such as when expecting another line of\n    // HTML, or we resulted in lazy content), we can immediately start flow.\n    if (inspectResult && inspectResult.flowContinue) {\n      return flowStart(code);\n    }\n\n    self.interrupt = childFlow && childFlow.currentConstruct && childFlow.currentConstruct.interruptible;\n    self.containerState = {};\n    return effects.attempt(containerConstruct, containerContinue, flowStart)(code);\n  }\n\n  function containerContinue(code) {\n    stack.push([self.currentConstruct, self.containerState]);\n    self.containerState = undefined;\n    return documentContinued(code);\n  }\n\n  function flowStart(code) {\n    if (code === null) {\n      exitContainers(0, true);\n      effects.consume(code);\n      return;\n    }\n\n    childFlow = childFlow || self.parser.flow(self.now());\n    effects.enter('chunkFlow', {\n      contentType: 'flow',\n      previous: childToken,\n      _tokenizer: childFlow\n    });\n    return flowContinue(code);\n  }\n\n  function flowContinue(code) {\n    if (code === null) {\n      continueFlow(effects.exit('chunkFlow'));\n      return flowStart(code);\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.consume(code);\n      continueFlow(effects.exit('chunkFlow'));\n      return effects.check(inspectConstruct, documentAfterPeek);\n    }\n\n    effects.consume(code);\n    return flowContinue;\n  }\n\n  function documentAfterPeek(code) {\n    exitContainers(inspectResult.continued, inspectResult && inspectResult.flowEnd);\n    continued = 0;\n    return start(code);\n  }\n\n  function continueFlow(token) {\n    if (childToken) childToken.next = token;\n    childToken = token;\n    childFlow.lazy = inspectResult && inspectResult.lazy;\n    childFlow.defineSkip(token.start);\n    childFlow.write(self.sliceStream(token));\n  }\n\n  function exitContainers(size, end) {\n    var index = stack.length; // Close the flow.\n\n    if (childFlow && end) {\n      childFlow.write([null]);\n      childToken = childFlow = undefined;\n    } // Exit open containers.\n\n\n    while (index-- > size) {\n      self.containerState = stack[index][1];\n      stack[index][0].exit.call(self, effects);\n    }\n\n    stack.length = size;\n  }\n\n  function tokenizeInspect(effects, ok) {\n    var subcontinued = 0;\n    inspectResult = {};\n    return inspectStart;\n\n    function inspectStart(code) {\n      if (subcontinued < stack.length) {\n        self.containerState = stack[subcontinued][1];\n        return effects.attempt(stack[subcontinued][0].continuation, inspectContinue, inspectLess)(code);\n      } // If we’re continued but in a concrete flow, we can’t have more\n      // containers.\n\n\n      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {\n        inspectResult.flowContinue = true;\n        return inspectDone(code);\n      }\n\n      self.interrupt = childFlow.currentConstruct && childFlow.currentConstruct.interruptible;\n      self.containerState = {};\n      return effects.attempt(containerConstruct, inspectFlowEnd, inspectDone)(code);\n    }\n\n    function inspectContinue(code) {\n      subcontinued++;\n      return self.containerState._closeFlow ? inspectFlowEnd(code) : inspectStart(code);\n    }\n\n    function inspectLess(code) {\n      if (childFlow.currentConstruct && childFlow.currentConstruct.lazy) {\n        // Maybe another container?\n        self.containerState = {};\n        return effects.attempt(containerConstruct, inspectFlowEnd, // Maybe flow, or a blank line?\n        effects.attempt(lazyFlowConstruct, inspectFlowEnd, effects.check(partialBlankLine, inspectFlowEnd, inspectLazy)))(code);\n      } // Otherwise we’re interrupting.\n\n\n      return inspectFlowEnd(code);\n    }\n\n    function inspectLazy(code) {\n      // Act as if all containers are continued.\n      subcontinued = stack.length;\n      inspectResult.lazy = true;\n      inspectResult.flowContinue = true;\n      return inspectDone(code);\n    } // We’re done with flow if we have more containers, or an interruption.\n\n\n    function inspectFlowEnd(code) {\n      inspectResult.flowEnd = true;\n      return inspectDone(code);\n    }\n\n    function inspectDone(code) {\n      inspectResult.continued = subcontinued;\n      self.interrupt = self.containerState = undefined;\n      return ok(code);\n    }\n  }\n}\n\nfunction tokenizeContainer(effects, ok, nok) {\n  return factorySpace(effects, effects.attempt(this.parser.constructs.document, ok, nok), 'linePrefix', this.parser.constructs.disable.null.indexOf('codeIndented') > -1 ? undefined : 4);\n}\n\nfunction tokenizeLazyFlow(effects, ok, nok) {\n  return factorySpace(effects, effects.lazy(this.parser.constructs.flow, ok, nok), 'linePrefix', this.parser.constructs.disable.null.indexOf('codeIndented') > -1 ? undefined : 4);\n}\n\nexports.tokenize = tokenize;","map":{"version":3,"sources":["/Users/allan.chepkoy/cloud/kubeflow/components/zoradashboard/node_modules/micromark/dist/initialize/document.js"],"names":["Object","defineProperty","exports","value","markdownLineEnding","require","factorySpace","partialBlankLine","tokenize","initializeDocument","containerConstruct","tokenizeContainer","lazyFlowConstruct","tokenizeLazyFlow","effects","self","stack","continued","inspectConstruct","tokenizeInspect","partial","inspectResult","childFlow","childToken","start","code","length","containerState","attempt","continuation","documentContinue","documentContinued","flowContinue","flowStart","interrupt","currentConstruct","interruptible","containerContinue","push","undefined","exitContainers","consume","parser","flow","now","enter","contentType","previous","_tokenizer","continueFlow","exit","check","documentAfterPeek","flowEnd","token","next","lazy","defineSkip","write","sliceStream","size","end","index","call","ok","subcontinued","inspectStart","inspectContinue","inspectLess","concrete","inspectDone","inspectFlowEnd","_closeFlow","inspectLazy","nok","constructs","document","disable","null","indexOf"],"mappings":"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","sourcesContent":["'use strict'\n\nObject.defineProperty(exports, '__esModule', {value: true})\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar factorySpace = require('../tokenize/factory-space.js')\nvar partialBlankLine = require('../tokenize/partial-blank-line.js')\n\nvar tokenize = initializeDocument\nvar containerConstruct = {\n  tokenize: tokenizeContainer\n}\nvar lazyFlowConstruct = {\n  tokenize: tokenizeLazyFlow\n}\n\nfunction initializeDocument(effects) {\n  var self = this\n  var stack = []\n  var continued = 0\n  var inspectConstruct = {\n    tokenize: tokenizeInspect,\n    partial: true\n  }\n  var inspectResult\n  var childFlow\n  var childToken\n  return start\n\n  function start(code) {\n    if (continued < stack.length) {\n      self.containerState = stack[continued][1]\n      return effects.attempt(\n        stack[continued][0].continuation,\n        documentContinue,\n        documentContinued\n      )(code)\n    }\n\n    return documentContinued(code)\n  }\n\n  function documentContinue(code) {\n    continued++\n    return start(code)\n  }\n\n  function documentContinued(code) {\n    // If we’re in a concrete construct (such as when expecting another line of\n    // HTML, or we resulted in lazy content), we can immediately start flow.\n    if (inspectResult && inspectResult.flowContinue) {\n      return flowStart(code)\n    }\n\n    self.interrupt =\n      childFlow &&\n      childFlow.currentConstruct &&\n      childFlow.currentConstruct.interruptible\n    self.containerState = {}\n    return effects.attempt(\n      containerConstruct,\n      containerContinue,\n      flowStart\n    )(code)\n  }\n\n  function containerContinue(code) {\n    stack.push([self.currentConstruct, self.containerState])\n    self.containerState = undefined\n    return documentContinued(code)\n  }\n\n  function flowStart(code) {\n    if (code === null) {\n      exitContainers(0, true)\n      effects.consume(code)\n      return\n    }\n\n    childFlow = childFlow || self.parser.flow(self.now())\n    effects.enter('chunkFlow', {\n      contentType: 'flow',\n      previous: childToken,\n      _tokenizer: childFlow\n    })\n    return flowContinue(code)\n  }\n\n  function flowContinue(code) {\n    if (code === null) {\n      continueFlow(effects.exit('chunkFlow'))\n      return flowStart(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.consume(code)\n      continueFlow(effects.exit('chunkFlow'))\n      return effects.check(inspectConstruct, documentAfterPeek)\n    }\n\n    effects.consume(code)\n    return flowContinue\n  }\n\n  function documentAfterPeek(code) {\n    exitContainers(\n      inspectResult.continued,\n      inspectResult && inspectResult.flowEnd\n    )\n    continued = 0\n    return start(code)\n  }\n\n  function continueFlow(token) {\n    if (childToken) childToken.next = token\n    childToken = token\n    childFlow.lazy = inspectResult && inspectResult.lazy\n    childFlow.defineSkip(token.start)\n    childFlow.write(self.sliceStream(token))\n  }\n\n  function exitContainers(size, end) {\n    var index = stack.length // Close the flow.\n\n    if (childFlow && end) {\n      childFlow.write([null])\n      childToken = childFlow = undefined\n    } // Exit open containers.\n\n    while (index-- > size) {\n      self.containerState = stack[index][1]\n      stack[index][0].exit.call(self, effects)\n    }\n\n    stack.length = size\n  }\n\n  function tokenizeInspect(effects, ok) {\n    var subcontinued = 0\n    inspectResult = {}\n    return inspectStart\n\n    function inspectStart(code) {\n      if (subcontinued < stack.length) {\n        self.containerState = stack[subcontinued][1]\n        return effects.attempt(\n          stack[subcontinued][0].continuation,\n          inspectContinue,\n          inspectLess\n        )(code)\n      } // If we’re continued but in a concrete flow, we can’t have more\n      // containers.\n\n      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {\n        inspectResult.flowContinue = true\n        return inspectDone(code)\n      }\n\n      self.interrupt =\n        childFlow.currentConstruct && childFlow.currentConstruct.interruptible\n      self.containerState = {}\n      return effects.attempt(\n        containerConstruct,\n        inspectFlowEnd,\n        inspectDone\n      )(code)\n    }\n\n    function inspectContinue(code) {\n      subcontinued++\n      return self.containerState._closeFlow\n        ? inspectFlowEnd(code)\n        : inspectStart(code)\n    }\n\n    function inspectLess(code) {\n      if (childFlow.currentConstruct && childFlow.currentConstruct.lazy) {\n        // Maybe another container?\n        self.containerState = {}\n        return effects.attempt(\n          containerConstruct,\n          inspectFlowEnd, // Maybe flow, or a blank line?\n          effects.attempt(\n            lazyFlowConstruct,\n            inspectFlowEnd,\n            effects.check(partialBlankLine, inspectFlowEnd, inspectLazy)\n          )\n        )(code)\n      } // Otherwise we’re interrupting.\n\n      return inspectFlowEnd(code)\n    }\n\n    function inspectLazy(code) {\n      // Act as if all containers are continued.\n      subcontinued = stack.length\n      inspectResult.lazy = true\n      inspectResult.flowContinue = true\n      return inspectDone(code)\n    } // We’re done with flow if we have more containers, or an interruption.\n\n    function inspectFlowEnd(code) {\n      inspectResult.flowEnd = true\n      return inspectDone(code)\n    }\n\n    function inspectDone(code) {\n      inspectResult.continued = subcontinued\n      self.interrupt = self.containerState = undefined\n      return ok(code)\n    }\n  }\n}\n\nfunction tokenizeContainer(effects, ok, nok) {\n  return factorySpace(\n    effects,\n    effects.attempt(this.parser.constructs.document, ok, nok),\n    'linePrefix',\n    this.parser.constructs.disable.null.indexOf('codeIndented') > -1\n      ? undefined\n      : 4\n  )\n}\n\nfunction tokenizeLazyFlow(effects, ok, nok) {\n  return factorySpace(\n    effects,\n    effects.lazy(this.parser.constructs.flow, ok, nok),\n    'linePrefix',\n    this.parser.constructs.disable.null.indexOf('codeIndented') > -1\n      ? undefined\n      : 4\n  )\n}\n\nexports.tokenize = tokenize\n"]},"metadata":{},"sourceType":"script"}