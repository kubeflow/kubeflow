{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar _bestFit = _interopRequireDefault(require(\"./bestFit\"));\n\nvar _linebreak = _interopRequireDefault(require(\"./linebreak\"));\n\nvar _slice = _interopRequireDefault(require(\"../../attributedString/slice\"));\n\nvar _insertGlyph = _interopRequireDefault(require(\"../../attributedString/insertGlyph\"));\n\nvar _advanceWidthBetween = _interopRequireDefault(require(\"../../attributedString/advanceWidthBetween\"));\n\nvar HYPHEN = 0x002d;\nvar TOLERANCE_STEPS = 5;\nvar TOLERANCE_LIMIT = 50;\nvar opts = {\n  width: 3,\n  stretch: 6,\n  shrink: 9\n};\n/**\n * Slice attributed string to many lines\n *\n * @param {Object} attributed string\n * @param  {Array}  nodes\n * @param  {Array}  breaks\n * @return {Array} attributed strings\n */\n\nvar breakLines = function breakLines(string, nodes, breaks) {\n  var start = 0;\n  var end = null;\n  var lines = breaks.reduce(function (acc, breakPoint) {\n    var node = nodes[breakPoint.position];\n    var prevNode = nodes[breakPoint.position - 1]; // Last breakpoint corresponds to K&P mandatory final glue\n\n    if (breakPoint.position === nodes.length - 1) return acc;\n    var line;\n\n    if (node.type === 'penalty') {\n      end = prevNode.value.end;\n      line = (0, _slice.default)(start, end, string);\n      line = (0, _insertGlyph.default)(line.length, HYPHEN, line);\n    } else {\n      end = node.value.end;\n      line = (0, _slice.default)(start, end, string);\n    }\n\n    start = end;\n    return [].concat(acc, [line]);\n  }, []); // Last line\n\n  lines.push((0, _slice.default)(start, string.string.length, string));\n  return lines;\n};\n/**\n * Return Knuth & Plass nodes based on line and previously calculated syllables\n *\n * @param {Object} attributed string\n * @param  {Object}  attributed string\n * @param  {Object}  layout options\n * @return {Array} attributed strings\n */\n\n\nvar getNodes = function getNodes(attributedString, _ref, options) {\n  var align = _ref.align;\n  var start = 0;\n  var hyphenWidth = 5;\n  var syllables = attributedString.syllables;\n  var hyphenPenalty = options.hyphenationPenalty || (align === 'justify' ? 100 : 600);\n  var result = syllables.reduce(function (acc, s, index) {\n    var width = (0, _advanceWidthBetween.default)(start, start + s.length, attributedString);\n\n    if (s.trim() === '') {\n      var stretch = width * opts.width / opts.stretch;\n      var shrink = width * opts.width / opts.shrink;\n      var value = {\n        start: start,\n        end: start + s.length\n      };\n      acc.push(_linebreak.default.glue(width, value, stretch, shrink));\n    } else {\n      var hyphenated = syllables[index + 1] !== ' ';\n      var _value = {\n        start: start,\n        end: start + s.length\n      };\n      acc.push(_linebreak.default.box(width, _value, hyphenated));\n\n      if (syllables[index + 1] && hyphenated) {\n        acc.push(_linebreak.default.penalty(hyphenWidth, hyphenPenalty, 1));\n      }\n    }\n\n    start += s.length;\n    return acc;\n  }, []);\n  result.push(_linebreak.default.glue(0, null, _linebreak.default.infinity, 0));\n  result.push(_linebreak.default.penalty(0, -_linebreak.default.infinity, 1));\n  return result;\n};\n\nvar getStyles = R.pathOr({}, ['attributedString', 'runs', 0, 'attributes']);\n/**\n * Performs Knuth & Plass line breaking algorithm\n * Fallbacks to best fit algorithm if latter not successful\n *\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @param {Object} attributed string\n * @return {Array} attributed strings\n */\n\nvar lineBreaker = function lineBreaker(options, attributedString, availableWidths) {\n  var tolerance = options.tolerance || 4;\n  var style = getStyles(attributedString);\n  var nodes = getNodes(attributedString, style, options);\n  var breaks = (0, _linebreak.default)(nodes, availableWidths, {\n    tolerance: tolerance\n  }); // Try again with a higher tolerance if the line breaking failed.\n\n  while (breaks.length === 0 && tolerance < TOLERANCE_LIMIT) {\n    tolerance += TOLERANCE_STEPS;\n    breaks = (0, _linebreak.default)(nodes, availableWidths, {\n      tolerance: tolerance\n    });\n  }\n\n  if (breaks.length === 0 || breaks.length === 1 && breaks[0].position === 0) {\n    breaks = (0, _bestFit.default)(nodes, availableWidths);\n  }\n\n  return breakLines(attributedString, nodes, breaks.slice(1));\n};\n\nvar _default = R.curryN(3, lineBreaker);\n\nexports.default = _default;","map":{"version":3,"sources":["/Users/allan.chepkoy/cloud/kubeflow/components/zoradashboard/node_modules/@react-pdf/textkit/lib/engines/linebreaker/index.js"],"names":["_interopRequireDefault","require","_interopRequireWildcard","exports","__esModule","default","R","_bestFit","_linebreak","_slice","_insertGlyph","_advanceWidthBetween","HYPHEN","TOLERANCE_STEPS","TOLERANCE_LIMIT","opts","width","stretch","shrink","breakLines","string","nodes","breaks","start","end","lines","reduce","acc","breakPoint","node","position","prevNode","length","line","type","value","concat","push","getNodes","attributedString","_ref","options","align","hyphenWidth","syllables","hyphenPenalty","hyphenationPenalty","result","s","index","trim","glue","hyphenated","_value","box","penalty","infinity","getStyles","pathOr","lineBreaker","availableWidths","tolerance","style","slice","_default","curryN"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar _bestFit = _interopRequireDefault(require(\"./bestFit\"));\n\nvar _linebreak = _interopRequireDefault(require(\"./linebreak\"));\n\nvar _slice = _interopRequireDefault(require(\"../../attributedString/slice\"));\n\nvar _insertGlyph = _interopRequireDefault(require(\"../../attributedString/insertGlyph\"));\n\nvar _advanceWidthBetween = _interopRequireDefault(require(\"../../attributedString/advanceWidthBetween\"));\n\nvar HYPHEN = 0x002d;\nvar TOLERANCE_STEPS = 5;\nvar TOLERANCE_LIMIT = 50;\nvar opts = {\n  width: 3,\n  stretch: 6,\n  shrink: 9\n};\n/**\n * Slice attributed string to many lines\n *\n * @param {Object} attributed string\n * @param  {Array}  nodes\n * @param  {Array}  breaks\n * @return {Array} attributed strings\n */\n\nvar breakLines = function breakLines(string, nodes, breaks) {\n  var start = 0;\n  var end = null;\n  var lines = breaks.reduce(function (acc, breakPoint) {\n    var node = nodes[breakPoint.position];\n    var prevNode = nodes[breakPoint.position - 1]; // Last breakpoint corresponds to K&P mandatory final glue\n\n    if (breakPoint.position === nodes.length - 1) return acc;\n    var line;\n\n    if (node.type === 'penalty') {\n      end = prevNode.value.end;\n      line = (0, _slice.default)(start, end, string);\n      line = (0, _insertGlyph.default)(line.length, HYPHEN, line);\n    } else {\n      end = node.value.end;\n      line = (0, _slice.default)(start, end, string);\n    }\n\n    start = end;\n    return [].concat(acc, [line]);\n  }, []); // Last line\n\n  lines.push((0, _slice.default)(start, string.string.length, string));\n  return lines;\n};\n/**\n * Return Knuth & Plass nodes based on line and previously calculated syllables\n *\n * @param {Object} attributed string\n * @param  {Object}  attributed string\n * @param  {Object}  layout options\n * @return {Array} attributed strings\n */\n\n\nvar getNodes = function getNodes(attributedString, _ref, options) {\n  var align = _ref.align;\n  var start = 0;\n  var hyphenWidth = 5;\n  var syllables = attributedString.syllables;\n  var hyphenPenalty = options.hyphenationPenalty || (align === 'justify' ? 100 : 600);\n  var result = syllables.reduce(function (acc, s, index) {\n    var width = (0, _advanceWidthBetween.default)(start, start + s.length, attributedString);\n\n    if (s.trim() === '') {\n      var stretch = width * opts.width / opts.stretch;\n      var shrink = width * opts.width / opts.shrink;\n      var value = {\n        start: start,\n        end: start + s.length\n      };\n      acc.push(_linebreak.default.glue(width, value, stretch, shrink));\n    } else {\n      var hyphenated = syllables[index + 1] !== ' ';\n      var _value = {\n        start: start,\n        end: start + s.length\n      };\n      acc.push(_linebreak.default.box(width, _value, hyphenated));\n\n      if (syllables[index + 1] && hyphenated) {\n        acc.push(_linebreak.default.penalty(hyphenWidth, hyphenPenalty, 1));\n      }\n    }\n\n    start += s.length;\n    return acc;\n  }, []);\n  result.push(_linebreak.default.glue(0, null, _linebreak.default.infinity, 0));\n  result.push(_linebreak.default.penalty(0, -_linebreak.default.infinity, 1));\n  return result;\n};\n\nvar getStyles = R.pathOr({}, ['attributedString', 'runs', 0, 'attributes']);\n/**\n * Performs Knuth & Plass line breaking algorithm\n * Fallbacks to best fit algorithm if latter not successful\n *\n * @param  {Object}  layout options\n * @param  {Object}  attributed string\n * @param {Object} attributed string\n * @return {Array} attributed strings\n */\n\nvar lineBreaker = function lineBreaker(options, attributedString, availableWidths) {\n  var tolerance = options.tolerance || 4;\n  var style = getStyles(attributedString);\n  var nodes = getNodes(attributedString, style, options);\n  var breaks = (0, _linebreak.default)(nodes, availableWidths, {\n    tolerance: tolerance\n  }); // Try again with a higher tolerance if the line breaking failed.\n\n  while (breaks.length === 0 && tolerance < TOLERANCE_LIMIT) {\n    tolerance += TOLERANCE_STEPS;\n    breaks = (0, _linebreak.default)(nodes, availableWidths, {\n      tolerance: tolerance\n    });\n  }\n\n  if (breaks.length === 0 || breaks.length === 1 && breaks[0].position === 0) {\n    breaks = (0, _bestFit.default)(nodes, availableWidths);\n  }\n\n  return breakLines(attributedString, nodes, breaks.slice(1));\n};\n\nvar _default = R.curryN(3, lineBreaker);\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}