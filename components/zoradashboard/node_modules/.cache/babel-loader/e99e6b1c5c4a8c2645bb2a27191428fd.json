{"ast":null,"code":"'use strict';\n\nvar assign = require('../constant/assign.js');\n\nvar chunkedSplice = require('./chunked-splice.js');\n\nvar shallow = require('./shallow.js');\n\nfunction subtokenize(events) {\n  var jumps = {};\n  var index = -1;\n  var event;\n  var lineIndex;\n  var otherIndex;\n  var otherEvent;\n  var parameters;\n  var subevents;\n  var more;\n\n  while (++index < events.length) {\n    while (index in jumps) {\n      index = jumps[index];\n    }\n\n    event = events[index]; // Add a hook for the GFM tasklist extension, which needs to know if text\n    // is in the first content of a list item.\n\n    if (index && event[1].type === 'chunkFlow' && events[index - 1][1].type === 'listItemPrefix') {\n      subevents = event[1]._tokenizer.events;\n      otherIndex = 0;\n\n      if (otherIndex < subevents.length && subevents[otherIndex][1].type === 'lineEndingBlank') {\n        otherIndex += 2;\n      }\n\n      if (otherIndex < subevents.length && subevents[otherIndex][1].type === 'content') {\n        while (++otherIndex < subevents.length) {\n          if (subevents[otherIndex][1].type === 'content') {\n            break;\n          }\n\n          if (subevents[otherIndex][1].type === 'chunkText') {\n            subevents[otherIndex][1].isInFirstContentOfListItem = true;\n            otherIndex++;\n          }\n        }\n      }\n    } // Enter.\n\n\n    if (event[0] === 'enter') {\n      if (event[1].contentType) {\n        assign(jumps, subcontent(events, index));\n        index = jumps[index];\n        more = true;\n      }\n    } // Exit.\n    else if (event[1]._container || event[1]._movePreviousLineEndings) {\n      otherIndex = index;\n      lineIndex = undefined;\n\n      while (otherIndex--) {\n        otherEvent = events[otherIndex];\n\n        if (otherEvent[1].type === 'lineEnding' || otherEvent[1].type === 'lineEndingBlank') {\n          if (otherEvent[0] === 'enter') {\n            if (lineIndex) {\n              events[lineIndex][1].type = 'lineEndingBlank';\n            }\n\n            otherEvent[1].type = 'lineEnding';\n            lineIndex = otherIndex;\n          }\n        } else {\n          break;\n        }\n      }\n\n      if (lineIndex) {\n        // Fix position.\n        event[1].end = shallow(events[lineIndex][1].start); // Switch container exit w/ line endings.\n\n        parameters = events.slice(lineIndex, index);\n        parameters.unshift(event);\n        chunkedSplice(events, lineIndex, index - lineIndex + 1, parameters);\n      }\n    }\n  }\n\n  return !more;\n}\n\nfunction subcontent(events, eventIndex) {\n  var token = events[eventIndex][1];\n  var context = events[eventIndex][2];\n  var startPosition = eventIndex - 1;\n  var startPositions = [];\n  var tokenizer = token._tokenizer || context.parser[token.contentType](token.start);\n  var childEvents = tokenizer.events;\n  var jumps = [];\n  var gaps = {};\n  var stream;\n  var previous;\n  var index;\n  var entered;\n  var end;\n  var adjust; // Loop forward through the linked tokens to pass them in order to the\n  // subtokenizer.\n\n  while (token) {\n    // Find the position of the event for this token.\n    while (events[++startPosition][1] !== token) {// Empty.\n    }\n\n    startPositions.push(startPosition);\n\n    if (!token._tokenizer) {\n      stream = context.sliceStream(token);\n\n      if (!token.next) {\n        stream.push(null);\n      }\n\n      if (previous) {\n        tokenizer.defineSkip(token.start);\n      }\n\n      if (token.isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = true;\n      }\n\n      tokenizer.write(stream);\n\n      if (token.isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = undefined;\n      }\n    } // Unravel the next token.\n\n\n    previous = token;\n    token = token.next;\n  } // Now, loop back through all events (and linked tokens), to figure out which\n  // parts belong where.\n\n\n  token = previous;\n  index = childEvents.length;\n\n  while (index--) {\n    // Make sure we’ve at least seen something (final eol is part of the last\n    // token).\n    if (childEvents[index][0] === 'enter') {\n      entered = true;\n    } else if ( // Find a void token that includes a break.\n    entered && childEvents[index][1].type === childEvents[index - 1][1].type && childEvents[index][1].start.line !== childEvents[index][1].end.line) {\n      add(childEvents.slice(index + 1, end)); // Help GC.\n\n      token._tokenizer = token.next = undefined;\n      token = token.previous;\n      end = index + 1;\n    }\n  } // Help GC.\n\n\n  tokenizer.events = token._tokenizer = token.next = undefined; // Do head:\n\n  add(childEvents.slice(0, end));\n  index = -1;\n  adjust = 0;\n\n  while (++index < jumps.length) {\n    gaps[adjust + jumps[index][0]] = adjust + jumps[index][1];\n    adjust += jumps[index][1] - jumps[index][0] - 1;\n  }\n\n  return gaps;\n\n  function add(slice) {\n    var start = startPositions.pop();\n    jumps.unshift([start, start + slice.length - 1]);\n    chunkedSplice(events, start, 2, slice);\n  }\n}\n\nmodule.exports = subtokenize;","map":{"version":3,"sources":["/Users/allan.chepkoy/cloud/kubeflow/components/zoradashboard/node_modules/micromark/dist/util/subtokenize.js"],"names":["assign","require","chunkedSplice","shallow","subtokenize","events","jumps","index","event","lineIndex","otherIndex","otherEvent","parameters","subevents","more","length","type","_tokenizer","isInFirstContentOfListItem","contentType","subcontent","_container","_movePreviousLineEndings","undefined","end","start","slice","unshift","eventIndex","token","context","startPosition","startPositions","tokenizer","parser","childEvents","gaps","stream","previous","entered","adjust","push","sliceStream","next","defineSkip","_gfmTasklistFirstContentOfListItem","write","line","add","pop","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nvar assign = require('../constant/assign.js')\nvar chunkedSplice = require('./chunked-splice.js')\nvar shallow = require('./shallow.js')\n\nfunction subtokenize(events) {\n  var jumps = {}\n  var index = -1\n  var event\n  var lineIndex\n  var otherIndex\n  var otherEvent\n  var parameters\n  var subevents\n  var more\n\n  while (++index < events.length) {\n    while (index in jumps) {\n      index = jumps[index]\n    }\n\n    event = events[index] // Add a hook for the GFM tasklist extension, which needs to know if text\n    // is in the first content of a list item.\n\n    if (\n      index &&\n      event[1].type === 'chunkFlow' &&\n      events[index - 1][1].type === 'listItemPrefix'\n    ) {\n      subevents = event[1]._tokenizer.events\n      otherIndex = 0\n\n      if (\n        otherIndex < subevents.length &&\n        subevents[otherIndex][1].type === 'lineEndingBlank'\n      ) {\n        otherIndex += 2\n      }\n\n      if (\n        otherIndex < subevents.length &&\n        subevents[otherIndex][1].type === 'content'\n      ) {\n        while (++otherIndex < subevents.length) {\n          if (subevents[otherIndex][1].type === 'content') {\n            break\n          }\n\n          if (subevents[otherIndex][1].type === 'chunkText') {\n            subevents[otherIndex][1].isInFirstContentOfListItem = true\n            otherIndex++\n          }\n        }\n      }\n    } // Enter.\n\n    if (event[0] === 'enter') {\n      if (event[1].contentType) {\n        assign(jumps, subcontent(events, index))\n        index = jumps[index]\n        more = true\n      }\n    } // Exit.\n    else if (event[1]._container || event[1]._movePreviousLineEndings) {\n      otherIndex = index\n      lineIndex = undefined\n\n      while (otherIndex--) {\n        otherEvent = events[otherIndex]\n\n        if (\n          otherEvent[1].type === 'lineEnding' ||\n          otherEvent[1].type === 'lineEndingBlank'\n        ) {\n          if (otherEvent[0] === 'enter') {\n            if (lineIndex) {\n              events[lineIndex][1].type = 'lineEndingBlank'\n            }\n\n            otherEvent[1].type = 'lineEnding'\n            lineIndex = otherIndex\n          }\n        } else {\n          break\n        }\n      }\n\n      if (lineIndex) {\n        // Fix position.\n        event[1].end = shallow(events[lineIndex][1].start) // Switch container exit w/ line endings.\n\n        parameters = events.slice(lineIndex, index)\n        parameters.unshift(event)\n        chunkedSplice(events, lineIndex, index - lineIndex + 1, parameters)\n      }\n    }\n  }\n\n  return !more\n}\n\nfunction subcontent(events, eventIndex) {\n  var token = events[eventIndex][1]\n  var context = events[eventIndex][2]\n  var startPosition = eventIndex - 1\n  var startPositions = []\n  var tokenizer =\n    token._tokenizer || context.parser[token.contentType](token.start)\n  var childEvents = tokenizer.events\n  var jumps = []\n  var gaps = {}\n  var stream\n  var previous\n  var index\n  var entered\n  var end\n  var adjust // Loop forward through the linked tokens to pass them in order to the\n  // subtokenizer.\n\n  while (token) {\n    // Find the position of the event for this token.\n    while (events[++startPosition][1] !== token) {\n      // Empty.\n    }\n\n    startPositions.push(startPosition)\n\n    if (!token._tokenizer) {\n      stream = context.sliceStream(token)\n\n      if (!token.next) {\n        stream.push(null)\n      }\n\n      if (previous) {\n        tokenizer.defineSkip(token.start)\n      }\n\n      if (token.isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = true\n      }\n\n      tokenizer.write(stream)\n\n      if (token.isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = undefined\n      }\n    } // Unravel the next token.\n\n    previous = token\n    token = token.next\n  } // Now, loop back through all events (and linked tokens), to figure out which\n  // parts belong where.\n\n  token = previous\n  index = childEvents.length\n\n  while (index--) {\n    // Make sure we’ve at least seen something (final eol is part of the last\n    // token).\n    if (childEvents[index][0] === 'enter') {\n      entered = true\n    } else if (\n      // Find a void token that includes a break.\n      entered &&\n      childEvents[index][1].type === childEvents[index - 1][1].type &&\n      childEvents[index][1].start.line !== childEvents[index][1].end.line\n    ) {\n      add(childEvents.slice(index + 1, end))\n      // Help GC.\n      token._tokenizer = token.next = undefined\n      token = token.previous\n      end = index + 1\n    }\n  }\n\n  // Help GC.\n  tokenizer.events = token._tokenizer = token.next = undefined // Do head:\n\n  add(childEvents.slice(0, end))\n  index = -1\n  adjust = 0\n\n  while (++index < jumps.length) {\n    gaps[adjust + jumps[index][0]] = adjust + jumps[index][1]\n    adjust += jumps[index][1] - jumps[index][0] - 1\n  }\n\n  return gaps\n\n  function add(slice) {\n    var start = startPositions.pop()\n    jumps.unshift([start, start + slice.length - 1])\n    chunkedSplice(events, start, 2, slice)\n  }\n}\n\nmodule.exports = subtokenize\n"]},"metadata":{},"sourceType":"script"}