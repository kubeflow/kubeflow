{"ast":null,"code":"var objectKeys = require('object-keys');\n\nvar isArguments = require('is-arguments');\n\nvar is = require('object-is');\n\nvar isRegex = require('is-regex');\n\nvar flags = require('regexp.prototype.flags');\n\nvar isDate = require('is-date-object');\n\nvar getTime = Date.prototype.getTime;\n\nfunction deepEqual(actual, expected, options) {\n  var opts = options || {}; // 7.1. All identical values are equivalent, as determined by ===.\n\n  if (opts.strict ? is(actual, expected) : actual === expected) {\n    return true;\n  } // 7.3. Other pairs that do not both pass typeof value == 'object', equivalence is determined by ==.\n\n\n  if (!actual || !expected || typeof actual !== 'object' && typeof expected !== 'object') {\n    return opts.strict ? is(actual, expected) : actual == expected;\n  }\n  /*\n   * 7.4. For all other Object pairs, including Array objects, equivalence is\n   * determined by having the same number of owned properties (as verified\n   * with Object.prototype.hasOwnProperty.call), the same set of keys\n   * (although not necessarily the same order), equivalent values for every\n   * corresponding key, and an identical 'prototype' property. Note: this\n   * accounts for both named and indexed properties on Arrays.\n   */\n  // eslint-disable-next-line no-use-before-define\n\n\n  return objEquiv(actual, expected, opts);\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isBuffer(x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') {\n    return false;\n  }\n\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n\n  if (x.length > 0 && typeof x[0] !== 'number') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction objEquiv(a, b, opts) {\n  /* eslint max-statements: [2, 50] */\n  var i, key;\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) {\n    return false;\n  } // an identical 'prototype' property.\n\n\n  if (a.prototype !== b.prototype) {\n    return false;\n  }\n\n  if (isArguments(a) !== isArguments(b)) {\n    return false;\n  }\n\n  var aIsRegex = isRegex(a);\n  var bIsRegex = isRegex(b);\n\n  if (aIsRegex !== bIsRegex) {\n    return false;\n  }\n\n  if (aIsRegex || bIsRegex) {\n    return a.source === b.source && flags(a) === flags(b);\n  }\n\n  if (isDate(a) && isDate(b)) {\n    return getTime.call(a) === getTime.call(b);\n  }\n\n  var aIsBuffer = isBuffer(a);\n  var bIsBuffer = isBuffer(b);\n\n  if (aIsBuffer !== bIsBuffer) {\n    return false;\n  }\n\n  if (aIsBuffer || bIsBuffer) {\n    // && would work too, because both are true or both false here\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  try {\n    var ka = objectKeys(a);\n    var kb = objectKeys(b);\n  } catch (e) {\n    // happens when one is a string literal and the other isn't\n    return false;\n  } // having the same number of owned properties (keys incorporates hasOwnProperty)\n\n\n  if (ka.length !== kb.length) {\n    return false;\n  } // the same set of keys (although not necessarily the same order),\n\n\n  ka.sort();\n  kb.sort(); // ~~~cheap key test\n\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i]) {\n      return false;\n    }\n  } // equivalent values for every corresponding key, and ~~~possibly expensive deep test\n\n\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n\n    if (!deepEqual(a[key], b[key], opts)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = deepEqual;","map":{"version":3,"sources":["/Users/allan.chepkoy/cloud/kubeflow/components/zoradashboard/node_modules/deep-equal/index.js"],"names":["objectKeys","require","isArguments","is","isRegex","flags","isDate","getTime","Date","prototype","deepEqual","actual","expected","options","opts","strict","objEquiv","isUndefinedOrNull","value","undefined","isBuffer","x","length","copy","slice","a","b","i","key","aIsRegex","bIsRegex","source","call","aIsBuffer","bIsBuffer","ka","kb","e","sort","module","exports"],"mappings":"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","sourcesContent":["var objectKeys = require('object-keys');\nvar isArguments = require('is-arguments');\nvar is = require('object-is');\nvar isRegex = require('is-regex');\nvar flags = require('regexp.prototype.flags');\nvar isDate = require('is-date-object');\n\nvar getTime = Date.prototype.getTime;\n\nfunction deepEqual(actual, expected, options) {\n  var opts = options || {};\n\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (opts.strict ? is(actual, expected) : actual === expected) {\n    return true;\n  }\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object', equivalence is determined by ==.\n  if (!actual || !expected || (typeof actual !== 'object' && typeof expected !== 'object')) {\n    return opts.strict ? is(actual, expected) : actual == expected;\n  }\n\n  /*\n   * 7.4. For all other Object pairs, including Array objects, equivalence is\n   * determined by having the same number of owned properties (as verified\n   * with Object.prototype.hasOwnProperty.call), the same set of keys\n   * (although not necessarily the same order), equivalent values for every\n   * corresponding key, and an identical 'prototype' property. Note: this\n   * accounts for both named and indexed properties on Arrays.\n   */\n  // eslint-disable-next-line no-use-before-define\n  return objEquiv(actual, expected, opts);\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isBuffer(x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') {\n    return false;\n  }\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n  if (x.length > 0 && typeof x[0] !== 'number') {\n    return false;\n  }\n  return true;\n}\n\nfunction objEquiv(a, b, opts) {\n  /* eslint max-statements: [2, 50] */\n  var i, key;\n  if (typeof a !== typeof b) { return false; }\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) { return false; }\n\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) { return false; }\n\n  if (isArguments(a) !== isArguments(b)) { return false; }\n\n  var aIsRegex = isRegex(a);\n  var bIsRegex = isRegex(b);\n  if (aIsRegex !== bIsRegex) { return false; }\n  if (aIsRegex || bIsRegex) {\n    return a.source === b.source && flags(a) === flags(b);\n  }\n\n  if (isDate(a) && isDate(b)) {\n    return getTime.call(a) === getTime.call(b);\n  }\n\n  var aIsBuffer = isBuffer(a);\n  var bIsBuffer = isBuffer(b);\n  if (aIsBuffer !== bIsBuffer) { return false; }\n  if (aIsBuffer || bIsBuffer) { // && would work too, because both are true or both false here\n    if (a.length !== b.length) { return false; }\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) { return false; }\n    }\n    return true;\n  }\n\n  if (typeof a !== typeof b) { return false; }\n\n  try {\n    var ka = objectKeys(a);\n    var kb = objectKeys(b);\n  } catch (e) { // happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates hasOwnProperty)\n  if (ka.length !== kb.length) { return false; }\n\n  // the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  // ~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i]) { return false; }\n  }\n  // equivalent values for every corresponding key, and ~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) { return false; }\n  }\n\n  return true;\n}\n\nmodule.exports = deepEqual;\n"]},"metadata":{},"sourceType":"script"}