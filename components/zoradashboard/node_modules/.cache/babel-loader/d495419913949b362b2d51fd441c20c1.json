{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar _advanceWidth = _interopRequireDefault(require(\"../attributedString/advanceWidth\"));\n\nvar _leadingOffset = _interopRequireDefault(require(\"../attributedString/leadingOffset\"));\n\nvar _trailingOffset = _interopRequireDefault(require(\"../attributedString/trailingOffset\"));\n\nvar _dropLast = _interopRequireDefault(require(\"../attributedString/dropLast\"));\n\nvar ALIGNMENT_FACTORS = {\n  left: 0,\n  center: 0.5,\n  right: 1,\n  justify: 0\n};\n/**\n * Remove new line char at the end of line if present\n *\n * @param  {Object}  line\n * @return {Object} line\n */\n\nvar removeNewLine = R.when(R.compose(R.equals('\\n'), R.last, R.prop('string')), _dropLast.default);\nvar getOverflowLeft = R.converge(R.add, [R.propOr(0, 'overflowLeft'), _leadingOffset.default]);\nvar getOverflowRight = R.converge(R.add, [R.propOr(0, 'overflowRight'), _trailingOffset.default]);\n/**\n * Ignore whitespace at the start and end of a line for alignment\n *\n * @param  {Object}  line\n * @return {Object} line\n */\n\nvar adjustOverflow = function adjustOverflow(line) {\n  var overflowLeft = getOverflowLeft(line);\n  var overflowRight = getOverflowRight(line);\n  return R.compose(R.assoc('overflowLeft', overflowLeft), R.assoc('overflowRight', overflowRight), R.evolve({\n    box: R.evolve({\n      x: R.subtract(R.__, overflowLeft),\n      width: R.add(overflowLeft + overflowRight)\n    })\n  }))(line);\n};\n/**\n * Performs line justification by calling appropiate engine\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {string}  text align\n * @param  {Object}  line\n * @return {Object} line\n */\n\n\nvar justifyLine = function justifyLine(engines, options, align) {\n  return function (line) {\n    var lineAdvanceWidth = (0, _advanceWidth.default)(line);\n    var remainingWidth = Math.max(0, line.box.width - lineAdvanceWidth);\n    var shouldJustify = align === 'justify' || lineAdvanceWidth > line.box.width;\n    return R.compose(R.when(R.always(shouldJustify), engines.justification(options)), R.evolve({\n      box: R.evolve({\n        x: R.add(remainingWidth * ALIGNMENT_FACTORS[align])\n      })\n    }))(line);\n  };\n};\n/**\n * Finalize line by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Object}  line\n * @param  {number}  line index\n * @param  {Array}  total lines\n * @return {Object} line\n */\n\n\nvar finalizeBlock = function finalizeBlock(engines, options) {\n  if (engines === void 0) {\n    engines = {};\n  }\n\n  return function (line, i, lines) {\n    var isLastFragment = i === lines.length - 1;\n    var style = R.pathOr({}, ['runs', 0, 'attributes'], line);\n    var align = isLastFragment ? style.alignLastLine : style.align;\n    return R.compose(engines.textDecoration(options), justifyLine(engines, options, align), adjustOverflow, removeNewLine)(line);\n  };\n};\n/**\n * Finalize line block by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Array}  line blocks\n * @return {Array} line blocks\n */\n\n\nvar finalizeFragments = function finalizeFragments(engines, options, blocks) {\n  return R.map(R.addIndex(R.map)(finalizeBlock(engines, options)), blocks);\n};\n\nvar _default = R.curryN(3, finalizeFragments);\n\nexports.default = _default;","map":{"version":3,"sources":["/Users/allan.chepkoy/cloud/kubeflow/components/zoradashboard/node_modules/@react-pdf/textkit/lib/layout/finalizeFragments.js"],"names":["_interopRequireDefault","require","_interopRequireWildcard","exports","__esModule","default","R","_advanceWidth","_leadingOffset","_trailingOffset","_dropLast","ALIGNMENT_FACTORS","left","center","right","justify","removeNewLine","when","compose","equals","last","prop","getOverflowLeft","converge","add","propOr","getOverflowRight","adjustOverflow","line","overflowLeft","overflowRight","assoc","evolve","box","x","subtract","__","width","justifyLine","engines","options","align","lineAdvanceWidth","remainingWidth","Math","max","shouldJustify","always","justification","finalizeBlock","i","lines","isLastFragment","length","style","pathOr","alignLastLine","textDecoration","finalizeFragments","blocks","map","addIndex","_default","curryN"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\nvar _advanceWidth = _interopRequireDefault(require(\"../attributedString/advanceWidth\"));\n\nvar _leadingOffset = _interopRequireDefault(require(\"../attributedString/leadingOffset\"));\n\nvar _trailingOffset = _interopRequireDefault(require(\"../attributedString/trailingOffset\"));\n\nvar _dropLast = _interopRequireDefault(require(\"../attributedString/dropLast\"));\n\nvar ALIGNMENT_FACTORS = {\n  left: 0,\n  center: 0.5,\n  right: 1,\n  justify: 0\n};\n/**\n * Remove new line char at the end of line if present\n *\n * @param  {Object}  line\n * @return {Object} line\n */\n\nvar removeNewLine = R.when(R.compose(R.equals('\\n'), R.last, R.prop('string')), _dropLast.default);\nvar getOverflowLeft = R.converge(R.add, [R.propOr(0, 'overflowLeft'), _leadingOffset.default]);\nvar getOverflowRight = R.converge(R.add, [R.propOr(0, 'overflowRight'), _trailingOffset.default]);\n/**\n * Ignore whitespace at the start and end of a line for alignment\n *\n * @param  {Object}  line\n * @return {Object} line\n */\n\nvar adjustOverflow = function adjustOverflow(line) {\n  var overflowLeft = getOverflowLeft(line);\n  var overflowRight = getOverflowRight(line);\n  return R.compose(R.assoc('overflowLeft', overflowLeft), R.assoc('overflowRight', overflowRight), R.evolve({\n    box: R.evolve({\n      x: R.subtract(R.__, overflowLeft),\n      width: R.add(overflowLeft + overflowRight)\n    })\n  }))(line);\n};\n/**\n * Performs line justification by calling appropiate engine\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {string}  text align\n * @param  {Object}  line\n * @return {Object} line\n */\n\n\nvar justifyLine = function justifyLine(engines, options, align) {\n  return function (line) {\n    var lineAdvanceWidth = (0, _advanceWidth.default)(line);\n    var remainingWidth = Math.max(0, line.box.width - lineAdvanceWidth);\n    var shouldJustify = align === 'justify' || lineAdvanceWidth > line.box.width;\n    return R.compose(R.when(R.always(shouldJustify), engines.justification(options)), R.evolve({\n      box: R.evolve({\n        x: R.add(remainingWidth * ALIGNMENT_FACTORS[align])\n      })\n    }))(line);\n  };\n};\n/**\n * Finalize line by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Object}  line\n * @param  {number}  line index\n * @param  {Array}  total lines\n * @return {Object} line\n */\n\n\nvar finalizeBlock = function finalizeBlock(engines, options) {\n  if (engines === void 0) {\n    engines = {};\n  }\n\n  return function (line, i, lines) {\n    var isLastFragment = i === lines.length - 1;\n    var style = R.pathOr({}, ['runs', 0, 'attributes'], line);\n    var align = isLastFragment ? style.alignLastLine : style.align;\n    return R.compose(engines.textDecoration(options), justifyLine(engines, options, align), adjustOverflow, removeNewLine)(line);\n  };\n};\n/**\n * Finalize line block by performing line justification\n * and text decoration (using appropiate engines)\n *\n * @param  {Object}  engines\n * @param  {Object}  layout options\n * @param  {Array}  line blocks\n * @return {Array} line blocks\n */\n\n\nvar finalizeFragments = function finalizeFragments(engines, options, blocks) {\n  return R.map(R.addIndex(R.map)(finalizeBlock(engines, options)), blocks);\n};\n\nvar _default = R.curryN(3, finalizeFragments);\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}