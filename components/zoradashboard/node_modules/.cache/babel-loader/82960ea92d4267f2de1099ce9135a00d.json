{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n/* eslint-disable no-plusplus */\n\nvar INFINITY = 10000;\n\nvar getNextBreakpoint = function getNextBreakpoint(subnodes, widths, lineNumber) {\n  var position = null;\n  var minimumBadness = Infinity;\n  var sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  var lineLength = widths[Math.min(lineNumber, widths.length - 1)];\n\n  var calculateRatio = function calculateRatio(node) {\n    if (sum.width < lineLength) {\n      return sum.stretch - node.stretch > 0 ? (lineLength - sum.width) / sum.stretch : INFINITY;\n    }\n\n    if (sum.width > lineLength) {\n      return sum.shrink - node.shrink > 0 ? (lineLength - sum.width) / sum.shrink : INFINITY;\n    }\n\n    return 0;\n  };\n\n  for (var i = 0; i < subnodes.length; i += 1) {\n    var node = subnodes[i];\n\n    if (node.type === 'box') {\n      sum.width += node.width;\n    } else if (node.type === 'glue') {\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n    }\n\n    if (sum.width - sum.shrink > lineLength) break;\n\n    if (node.type === 'penalty' || node.type === 'glue') {\n      var ratio = calculateRatio(node);\n      var penalty = node.type === 'penalty' ? node.penalty : 0;\n      var badness = 100 * Math.pow(Math.abs(ratio), 3) + penalty;\n\n      if (minimumBadness >= badness) {\n        position = i;\n        minimumBadness = badness;\n      }\n    }\n  }\n\n  return sum.width - sum.shrink > lineLength ? position : null;\n};\n\nvar applyBestFit = function applyBestFit(nodes, widths) {\n  var count = 0;\n  var lineNumber = 0;\n  var subnodes = nodes;\n  var breakpoints = [{\n    position: 0\n  }];\n\n  while (subnodes.length > 0) {\n    var breakpoint = getNextBreakpoint(subnodes, widths, lineNumber);\n\n    if (breakpoint) {\n      count += breakpoint;\n      breakpoints.push({\n        position: count\n      });\n      subnodes = subnodes.slice(breakpoint + 1, subnodes.length);\n      count++;\n      lineNumber++;\n    } else {\n      subnodes = [];\n    }\n  }\n\n  return breakpoints;\n};\n\nvar _default = applyBestFit;\nexports.default = _default;","map":{"version":3,"sources":["/Users/allan.chepkoy/cloud/kubeflow/components/zoradashboard/node_modules/@react-pdf/textkit/lib/engines/linebreaker/bestFit.js"],"names":["exports","__esModule","default","INFINITY","getNextBreakpoint","subnodes","widths","lineNumber","position","minimumBadness","Infinity","sum","width","stretch","shrink","lineLength","Math","min","length","calculateRatio","node","i","type","ratio","penalty","badness","pow","abs","applyBestFit","nodes","count","breakpoints","breakpoint","push","slice","_default"],"mappings":"AAAA;;AAEAA,OAAO,CAACC,UAAR,GAAqB,IAArB;AACAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;AAEA;;AACA,IAAIC,QAAQ,GAAG,KAAf;;AAEA,IAAIC,iBAAiB,GAAG,SAASA,iBAAT,CAA2BC,QAA3B,EAAqCC,MAArC,EAA6CC,UAA7C,EAAyD;AAC/E,MAAIC,QAAQ,GAAG,IAAf;AACA,MAAIC,cAAc,GAAGC,QAArB;AACA,MAAIC,GAAG,GAAG;AACRC,IAAAA,KAAK,EAAE,CADC;AAERC,IAAAA,OAAO,EAAE,CAFD;AAGRC,IAAAA,MAAM,EAAE;AAHA,GAAV;AAKA,MAAIC,UAAU,GAAGT,MAAM,CAACU,IAAI,CAACC,GAAL,CAASV,UAAT,EAAqBD,MAAM,CAACY,MAAP,GAAgB,CAArC,CAAD,CAAvB;;AAEA,MAAIC,cAAc,GAAG,SAASA,cAAT,CAAwBC,IAAxB,EAA8B;AACjD,QAAIT,GAAG,CAACC,KAAJ,GAAYG,UAAhB,EAA4B;AAC1B,aAAOJ,GAAG,CAACE,OAAJ,GAAcO,IAAI,CAACP,OAAnB,GAA6B,CAA7B,GAAiC,CAACE,UAAU,GAAGJ,GAAG,CAACC,KAAlB,IAA2BD,GAAG,CAACE,OAAhE,GAA0EV,QAAjF;AACD;;AAED,QAAIQ,GAAG,CAACC,KAAJ,GAAYG,UAAhB,EAA4B;AAC1B,aAAOJ,GAAG,CAACG,MAAJ,GAAaM,IAAI,CAACN,MAAlB,GAA2B,CAA3B,GAA+B,CAACC,UAAU,GAAGJ,GAAG,CAACC,KAAlB,IAA2BD,GAAG,CAACG,MAA9D,GAAuEX,QAA9E;AACD;;AAED,WAAO,CAAP;AACD,GAVD;;AAYA,OAAK,IAAIkB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhB,QAAQ,CAACa,MAA7B,EAAqCG,CAAC,IAAI,CAA1C,EAA6C;AAC3C,QAAID,IAAI,GAAGf,QAAQ,CAACgB,CAAD,CAAnB;;AAEA,QAAID,IAAI,CAACE,IAAL,KAAc,KAAlB,EAAyB;AACvBX,MAAAA,GAAG,CAACC,KAAJ,IAAaQ,IAAI,CAACR,KAAlB;AACD,KAFD,MAEO,IAAIQ,IAAI,CAACE,IAAL,KAAc,MAAlB,EAA0B;AAC/BX,MAAAA,GAAG,CAACC,KAAJ,IAAaQ,IAAI,CAACR,KAAlB;AACAD,MAAAA,GAAG,CAACE,OAAJ,IAAeO,IAAI,CAACP,OAApB;AACAF,MAAAA,GAAG,CAACG,MAAJ,IAAcM,IAAI,CAACN,MAAnB;AACD;;AAED,QAAIH,GAAG,CAACC,KAAJ,GAAYD,GAAG,CAACG,MAAhB,GAAyBC,UAA7B,EAAyC;;AAEzC,QAAIK,IAAI,CAACE,IAAL,KAAc,SAAd,IAA2BF,IAAI,CAACE,IAAL,KAAc,MAA7C,EAAqD;AACnD,UAAIC,KAAK,GAAGJ,cAAc,CAACC,IAAD,CAA1B;AACA,UAAII,OAAO,GAAGJ,IAAI,CAACE,IAAL,KAAc,SAAd,GAA0BF,IAAI,CAACI,OAA/B,GAAyC,CAAvD;AACA,UAAIC,OAAO,GAAG,MAAMT,IAAI,CAACU,GAAL,CAASV,IAAI,CAACW,GAAL,CAASJ,KAAT,CAAT,EAA0B,CAA1B,CAAN,GAAqCC,OAAnD;;AAEA,UAAIf,cAAc,IAAIgB,OAAtB,EAA+B;AAC7BjB,QAAAA,QAAQ,GAAGa,CAAX;AACAZ,QAAAA,cAAc,GAAGgB,OAAjB;AACD;AACF;AACF;;AAED,SAAOd,GAAG,CAACC,KAAJ,GAAYD,GAAG,CAACG,MAAhB,GAAyBC,UAAzB,GAAsCP,QAAtC,GAAiD,IAAxD;AACD,CAhDD;;AAkDA,IAAIoB,YAAY,GAAG,SAASA,YAAT,CAAsBC,KAAtB,EAA6BvB,MAA7B,EAAqC;AACtD,MAAIwB,KAAK,GAAG,CAAZ;AACA,MAAIvB,UAAU,GAAG,CAAjB;AACA,MAAIF,QAAQ,GAAGwB,KAAf;AACA,MAAIE,WAAW,GAAG,CAAC;AACjBvB,IAAAA,QAAQ,EAAE;AADO,GAAD,CAAlB;;AAIA,SAAOH,QAAQ,CAACa,MAAT,GAAkB,CAAzB,EAA4B;AAC1B,QAAIc,UAAU,GAAG5B,iBAAiB,CAACC,QAAD,EAAWC,MAAX,EAAmBC,UAAnB,CAAlC;;AAEA,QAAIyB,UAAJ,EAAgB;AACdF,MAAAA,KAAK,IAAIE,UAAT;AACAD,MAAAA,WAAW,CAACE,IAAZ,CAAiB;AACfzB,QAAAA,QAAQ,EAAEsB;AADK,OAAjB;AAGAzB,MAAAA,QAAQ,GAAGA,QAAQ,CAAC6B,KAAT,CAAeF,UAAU,GAAG,CAA5B,EAA+B3B,QAAQ,CAACa,MAAxC,CAAX;AACAY,MAAAA,KAAK;AACLvB,MAAAA,UAAU;AACX,KARD,MAQO;AACLF,MAAAA,QAAQ,GAAG,EAAX;AACD;AACF;;AAED,SAAO0B,WAAP;AACD,CAzBD;;AA2BA,IAAII,QAAQ,GAAGP,YAAf;AACA5B,OAAO,CAACE,OAAR,GAAkBiC,QAAlB","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\n/* eslint-disable no-plusplus */\nvar INFINITY = 10000;\n\nvar getNextBreakpoint = function getNextBreakpoint(subnodes, widths, lineNumber) {\n  var position = null;\n  var minimumBadness = Infinity;\n  var sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  var lineLength = widths[Math.min(lineNumber, widths.length - 1)];\n\n  var calculateRatio = function calculateRatio(node) {\n    if (sum.width < lineLength) {\n      return sum.stretch - node.stretch > 0 ? (lineLength - sum.width) / sum.stretch : INFINITY;\n    }\n\n    if (sum.width > lineLength) {\n      return sum.shrink - node.shrink > 0 ? (lineLength - sum.width) / sum.shrink : INFINITY;\n    }\n\n    return 0;\n  };\n\n  for (var i = 0; i < subnodes.length; i += 1) {\n    var node = subnodes[i];\n\n    if (node.type === 'box') {\n      sum.width += node.width;\n    } else if (node.type === 'glue') {\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n    }\n\n    if (sum.width - sum.shrink > lineLength) break;\n\n    if (node.type === 'penalty' || node.type === 'glue') {\n      var ratio = calculateRatio(node);\n      var penalty = node.type === 'penalty' ? node.penalty : 0;\n      var badness = 100 * Math.pow(Math.abs(ratio), 3) + penalty;\n\n      if (minimumBadness >= badness) {\n        position = i;\n        minimumBadness = badness;\n      }\n    }\n  }\n\n  return sum.width - sum.shrink > lineLength ? position : null;\n};\n\nvar applyBestFit = function applyBestFit(nodes, widths) {\n  var count = 0;\n  var lineNumber = 0;\n  var subnodes = nodes;\n  var breakpoints = [{\n    position: 0\n  }];\n\n  while (subnodes.length > 0) {\n    var breakpoint = getNextBreakpoint(subnodes, widths, lineNumber);\n\n    if (breakpoint) {\n      count += breakpoint;\n      breakpoints.push({\n        position: count\n      });\n      subnodes = subnodes.slice(breakpoint + 1, subnodes.length);\n      count++;\n      lineNumber++;\n    } else {\n      subnodes = [];\n    }\n  }\n\n  return breakpoints;\n};\n\nvar _default = applyBestFit;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}