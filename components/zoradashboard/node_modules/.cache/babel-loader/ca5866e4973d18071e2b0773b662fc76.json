{"ast":null,"code":"'use strict';\n/*eslint-disable no-use-before-define*/\n\nvar common = require('./common');\n\nvar YAMLException = require('./exception');\n\nvar DEFAULT_FULL_SCHEMA = require('./schema/default_full');\n\nvar DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\n\nvar _toString = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar CHAR_TAB = 0x09;\n/* Tab */\n\nvar CHAR_LINE_FEED = 0x0A;\n/* LF */\n\nvar CHAR_CARRIAGE_RETURN = 0x0D;\n/* CR */\n\nvar CHAR_SPACE = 0x20;\n/* Space */\n\nvar CHAR_EXCLAMATION = 0x21;\n/* ! */\n\nvar CHAR_DOUBLE_QUOTE = 0x22;\n/* \" */\n\nvar CHAR_SHARP = 0x23;\n/* # */\n\nvar CHAR_PERCENT = 0x25;\n/* % */\n\nvar CHAR_AMPERSAND = 0x26;\n/* & */\n\nvar CHAR_SINGLE_QUOTE = 0x27;\n/* ' */\n\nvar CHAR_ASTERISK = 0x2A;\n/* * */\n\nvar CHAR_COMMA = 0x2C;\n/* , */\n\nvar CHAR_MINUS = 0x2D;\n/* - */\n\nvar CHAR_COLON = 0x3A;\n/* : */\n\nvar CHAR_EQUALS = 0x3D;\n/* = */\n\nvar CHAR_GREATER_THAN = 0x3E;\n/* > */\n\nvar CHAR_QUESTION = 0x3F;\n/* ? */\n\nvar CHAR_COMMERCIAL_AT = 0x40;\n/* @ */\n\nvar CHAR_LEFT_SQUARE_BRACKET = 0x5B;\n/* [ */\n\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D;\n/* ] */\n\nvar CHAR_GRAVE_ACCENT = 0x60;\n/* ` */\n\nvar CHAR_LEFT_CURLY_BRACKET = 0x7B;\n/* { */\n\nvar CHAR_VERTICAL_LINE = 0x7C;\n/* | */\n\nvar CHAR_RIGHT_CURLY_BRACKET = 0x7D;\n/* } */\n\nvar ESCAPE_SEQUENCES = {};\nESCAPE_SEQUENCES[0x00] = '\\\\0';\nESCAPE_SEQUENCES[0x07] = '\\\\a';\nESCAPE_SEQUENCES[0x08] = '\\\\b';\nESCAPE_SEQUENCES[0x09] = '\\\\t';\nESCAPE_SEQUENCES[0x0A] = '\\\\n';\nESCAPE_SEQUENCES[0x0B] = '\\\\v';\nESCAPE_SEQUENCES[0x0C] = '\\\\f';\nESCAPE_SEQUENCES[0x0D] = '\\\\r';\nESCAPE_SEQUENCES[0x1B] = '\\\\e';\nESCAPE_SEQUENCES[0x22] = '\\\\\"';\nESCAPE_SEQUENCES[0x5C] = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85] = '\\\\N';\nESCAPE_SEQUENCES[0xA0] = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\nvar DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n  if (map === null) return {};\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\nfunction State(options) {\n  this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;\n  this.indent = Math.max(1, options['indent'] || 2);\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid = options['skipInvalid'] || false;\n  this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];\n  this.styleMap = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys = options['sortKeys'] || false;\n  this.lineWidth = options['lineWidth'] || 80;\n  this.noRefs = options['noRefs'] || false;\n  this.noCompatMode = options['noCompatMode'] || false;\n  this.condenseFlow = options['condenseFlow'] || false;\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n  this.tag = null;\n  this.result = '';\n  this.duplicates = [];\n  this.usedDuplicates = null;\n} // Indents every line in a string. Empty lines (\\n only) are not indented.\n\n\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n} // [33] s-white ::= s-space | s-tab\n\n\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n} // Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isn’t mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\n\n\nfunction isPrintable(c) {\n  return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== 0xFEFF\n  /* BOM */\n  || 0x10000 <= c && c <= 0x10FFFF;\n} // [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// [24] b-line-feed       ::=     #xA    /* LF */\n// [25] b-carriage-return ::=     #xD    /* CR */\n// [3]  c-byte-order-mark ::=     #xFEFF\n\n\nfunction isNsChar(c) {\n  return isPrintable(c) && !isWhitespace(c) // byte-order-mark\n  && c !== 0xFEFF // b-char\n  && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;\n} // Simplified test for values allowed after the first character in plain style.\n\n\nfunction isPlainSafe(c, prev) {\n  // Uses a subset of nb-char - c-flow-indicator - \":\" - \"#\"\n  // where nb-char ::= c-printable - b-char - c-byte-order-mark.\n  return isPrintable(c) && c !== 0xFEFF // - c-flow-indicator\n  && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET // - \":\" - \"#\"\n  // /* An ns-char preceding */ \"#\"\n  && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));\n} // Simplified test for values allowed as the first character in plain style.\n\n\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  return isPrintable(c) && c !== 0xFEFF && !isWhitespace(c) // - s-white\n  // - (c-indicator ::=\n  // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”\n  && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “\"”\n  && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE // | “%” | “@” | “`”)\n  && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;\n} // Determines whether block indentation indicator is required.\n\n\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN = 1,\n    STYLE_SINGLE = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED = 4,\n    STYLE_DOUBLE = 5; // Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\n\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {\n  var i;\n  var char, prev_char;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n\n  var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));\n\n  if (singleLineOnly) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; i++) {\n      char = string.charCodeAt(i);\n\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n\n      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n      plain = plain && isPlainSafe(char, prev_char);\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; i++) {\n      char = string.charCodeAt(i);\n\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true; // Check if any line can be folded.\n\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n\n      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n      plain = plain && isPlainSafe(char, prev_char);\n    } // in case the end is missing a \\n\n\n\n    hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';\n  } // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n\n\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;\n  } // Edge case: block indentation indicator can only have one digit.\n\n\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  } // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n\n\n  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n} // Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//    • No ending newline => unaffected; already using strip \"-\" chomping.\n//    • Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\n\n\nfunction writeScalar(state, string, level, iskey) {\n  state.dump = function () {\n    if (string.length === 0) {\n      return \"''\";\n    }\n\n    if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {\n      return \"'\" + string + \"'\";\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n\n    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent); // Without knowing if keys are implicit/explicit, assume implicit for safety.\n\n    var singleLineOnly = iskey // No block styles in flow mode.\n    || state.flowLevel > -1 && level >= state.flowLevel;\n\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {\n      case STYLE_PLAIN:\n        return string;\n\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));\n\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string, lineWidth) + '\"';\n\n      default:\n        throw new YAMLException('impossible error: invalid scalar style');\n    }\n  }();\n} // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\n\n\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : ''; // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n\n  var clip = string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : clip ? '' : '-';\n  return indentIndicator + chomp + '\\n';\n} // (See the note for writeScalar.)\n\n\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n} // Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\n\n\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g; // first line (possibly an empty line)\n\n  var result = function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }(); // If we haven't reached the first content line yet, don't add an extra \\n.\n\n\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented; // rest of the lines\n\n  var match;\n\n  while (match = lineRe.exec(string)) {\n    var prefix = match[1],\n        line = match[2];\n    moreIndented = line[0] === ' ';\n    result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\\n' : '') + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n} // Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\n\n\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line; // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n\n  var match; // start is an inclusive index. end, curr, and next are exclusive.\n\n  var start = 0,\n      end,\n      curr = 0,\n      next = 0;\n  var result = ''; // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n\n  while (match = breakRe.exec(line)) {\n    next = match.index; // maintain invariant: curr - start <= width\n\n    if (next - start > width) {\n      end = curr > start ? curr : next; // derive end <= length-2\n\n      result += '\\n' + line.slice(start, end); // skip the space that was output as \\n\n\n      start = end + 1; // derive start <= length-1\n    }\n\n    curr = next;\n  } // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n\n\n  result += '\\n'; // Insert a break if the remainder is too long and there is a break available.\n\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n} // Escapes a double-quoted string.\n\n\nfunction escapeString(string) {\n  var result = '';\n  var char, nextChar;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; i++) {\n    char = string.charCodeAt(i); // Check for surrogate pairs (reference Unicode 3.0 section \"3.7 Surrogates\").\n\n    if (char >= 0xD800 && char <= 0xDBFF\n    /* high surrogate */\n    ) {\n      nextChar = string.charCodeAt(i + 1);\n\n      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF\n      /* low surrogate */\n      ) {\n        // Combine the surrogate pair and store it escaped.\n        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000); // Advance index one extra since we already used that char here.\n\n        i++;\n        continue;\n      }\n    }\n\n    escapeSeq = ESCAPE_SEQUENCES[char];\n    result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level, object[index], false, false)) {\n      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level + 1, object[index], true, true)) {\n      if (!compact || index !== 0) {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result = '',\n      _tag = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n    if (index !== 0) pairBuffer += ', ';\n    if (state.condenseFlow) pairBuffer += '\"';\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump; // Both key and value are valid.\n\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result = '',\n      _tag = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer; // Allow sorting keys so that the output file is deterministic\n\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new YAMLException('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || index !== 0) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump; // Both key and value are valid.\n\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {\n      state.tag = explicit ? type.tag : '?';\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n} // Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\n\n\nfunction writeNode(state, level, object, block, compact, iskey) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n\n  if (block) {\n    block = state.flowLevel < 0 || state.flowLevel > level;\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n\n    if (type === '[object Object]') {\n      if (block && Object.keys(state.dump).length !== 0) {\n        writeBlockMapping(state, level, state.dump, compact);\n\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;\n\n      if (block && state.dump.length !== 0) {\n        writeBlockSequence(state, arrayLevel, state.dump, compact);\n\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, arrayLevel, state.dump);\n\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey);\n      }\n    } else {\n      if (state.skipInvalid) return false;\n      throw new YAMLException('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      state.dump = '!<' + state.tag + '> ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList, index, length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump(input, options) {\n  options = options || {};\n  var state = new State(options);\n  if (!state.noRefs) getDuplicateReferences(input, state);\n  if (writeNode(state, 0, input, true, true)) return state.dump + '\\n';\n  return '';\n}\n\nfunction safeDump(input, options) {\n  return dump(input, common.extend({\n    schema: DEFAULT_SAFE_SCHEMA\n  }, options));\n}\n\nmodule.exports.dump = dump;\nmodule.exports.safeDump = safeDump;","map":{"version":3,"sources":["/Users/allan.chepkoy/cloud/kubeflow/components/zoradashboard/node_modules/js-yaml/lib/js-yaml/dumper.js"],"names":["common","require","YAMLException","DEFAULT_FULL_SCHEMA","DEFAULT_SAFE_SCHEMA","_toString","Object","prototype","toString","_hasOwnProperty","hasOwnProperty","CHAR_TAB","CHAR_LINE_FEED","CHAR_CARRIAGE_RETURN","CHAR_SPACE","CHAR_EXCLAMATION","CHAR_DOUBLE_QUOTE","CHAR_SHARP","CHAR_PERCENT","CHAR_AMPERSAND","CHAR_SINGLE_QUOTE","CHAR_ASTERISK","CHAR_COMMA","CHAR_MINUS","CHAR_COLON","CHAR_EQUALS","CHAR_GREATER_THAN","CHAR_QUESTION","CHAR_COMMERCIAL_AT","CHAR_LEFT_SQUARE_BRACKET","CHAR_RIGHT_SQUARE_BRACKET","CHAR_GRAVE_ACCENT","CHAR_LEFT_CURLY_BRACKET","CHAR_VERTICAL_LINE","CHAR_RIGHT_CURLY_BRACKET","ESCAPE_SEQUENCES","DEPRECATED_BOOLEANS_SYNTAX","compileStyleMap","schema","map","result","keys","index","length","tag","style","type","String","slice","compiledTypeMap","call","styleAliases","encodeHex","character","string","handle","toUpperCase","repeat","State","options","indent","Math","max","noArrayIndent","skipInvalid","flowLevel","isNothing","styleMap","sortKeys","lineWidth","noRefs","noCompatMode","condenseFlow","implicitTypes","compiledImplicit","explicitTypes","compiledExplicit","duplicates","usedDuplicates","indentString","spaces","ind","position","next","line","indexOf","generateNextLine","state","level","testImplicitResolving","str","resolve","isWhitespace","c","isPrintable","isNsChar","isPlainSafe","prev","isPlainSafeFirst","needIndentIndicator","leadingSpaceRe","test","STYLE_PLAIN","STYLE_SINGLE","STYLE_LITERAL","STYLE_FOLDED","STYLE_DOUBLE","chooseScalarStyle","singleLineOnly","indentPerLevel","testAmbiguousType","i","char","prev_char","hasLineBreak","hasFoldableLine","shouldTrackWidth","previousLineBreak","plain","charCodeAt","writeScalar","iskey","dump","min","testAmbiguity","replace","blockHeader","dropEndingNewline","foldString","escapeString","indentIndicator","clip","keep","chomp","width","lineRe","nextLF","lastIndex","foldLine","prevMoreIndented","moreIndented","match","exec","prefix","breakRe","start","end","curr","nextChar","escapeSeq","writeFlowSequence","object","_result","_tag","writeNode","writeBlockSequence","compact","writeFlowMapping","objectKeyList","objectKey","objectValue","pairBuffer","writeBlockMapping","explicitPair","sort","detectType","explicit","typeList","instanceOf","predicate","represent","defaultStyle","block","objectOrArray","duplicateIndex","duplicate","arrayLevel","getDuplicateReferences","objects","duplicatesIndexes","inspectNode","push","Array","isArray","input","safeDump","extend","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/*eslint-disable no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar DEFAULT_FULL_SCHEMA = require('./schema/default_full');\nvar DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\n\nvar _toString       = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar CHAR_TAB                  = 0x09; /* Tab */\nvar CHAR_LINE_FEED            = 0x0A; /* LF */\nvar CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */\nvar CHAR_SPACE                = 0x20; /* Space */\nvar CHAR_EXCLAMATION          = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\nvar CHAR_SHARP                = 0x23; /* # */\nvar CHAR_PERCENT              = 0x25; /* % */\nvar CHAR_AMPERSAND            = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE         = 0x27; /* ' */\nvar CHAR_ASTERISK             = 0x2A; /* * */\nvar CHAR_COMMA                = 0x2C; /* , */\nvar CHAR_MINUS                = 0x2D; /* - */\nvar CHAR_COLON                = 0x3A; /* : */\nvar CHAR_EQUALS               = 0x3D; /* = */\nvar CHAR_GREATER_THAN         = 0x3E; /* > */\nvar CHAR_QUESTION             = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT        = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT         = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE        = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\n\nESCAPE_SEQUENCES[0x00]   = '\\\\0';\nESCAPE_SEQUENCES[0x07]   = '\\\\a';\nESCAPE_SEQUENCES[0x08]   = '\\\\b';\nESCAPE_SEQUENCES[0x09]   = '\\\\t';\nESCAPE_SEQUENCES[0x0A]   = '\\\\n';\nESCAPE_SEQUENCES[0x0B]   = '\\\\v';\nESCAPE_SEQUENCES[0x0C]   = '\\\\f';\nESCAPE_SEQUENCES[0x0D]   = '\\\\r';\nESCAPE_SEQUENCES[0x1B]   = '\\\\e';\nESCAPE_SEQUENCES[0x22]   = '\\\\\"';\nESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85]   = '\\\\N';\nESCAPE_SEQUENCES[0xA0]   = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n];\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n\n  if (map === null) return {};\n\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\nfunction State(options) {\n  this.schema        = options['schema'] || DEFAULT_FULL_SCHEMA;\n  this.indent        = Math.max(1, (options['indent'] || 2));\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid   = options['skipInvalid'] || false;\n  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys      = options['sortKeys'] || false;\n  this.lineWidth     = options['lineWidth'] || 80;\n  this.noRefs        = options['noRefs'] || false;\n  this.noCompatMode  = options['noCompatMode'] || false;\n  this.condenseFlow  = options['condenseFlow'] || false;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n\n  this.tag = null;\n  this.result = '';\n\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\n\n// Indents every line in a string. Empty lines (\\n only) are not indented.\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// [33] s-white ::= s-space | s-tab\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n}\n\n// Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isn’t mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\nfunction isPrintable(c) {\n  return  (0x00020 <= c && c <= 0x00007E)\n      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)\n      ||  (0x10000 <= c && c <= 0x10FFFF);\n}\n\n// [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// [24] b-line-feed       ::=     #xA    /* LF */\n// [25] b-carriage-return ::=     #xD    /* CR */\n// [3]  c-byte-order-mark ::=     #xFEFF\nfunction isNsChar(c) {\n  return isPrintable(c) && !isWhitespace(c)\n    // byte-order-mark\n    && c !== 0xFEFF\n    // b-char\n    && c !== CHAR_CARRIAGE_RETURN\n    && c !== CHAR_LINE_FEED;\n}\n\n// Simplified test for values allowed after the first character in plain style.\nfunction isPlainSafe(c, prev) {\n  // Uses a subset of nb-char - c-flow-indicator - \":\" - \"#\"\n  // where nb-char ::= c-printable - b-char - c-byte-order-mark.\n  return isPrintable(c) && c !== 0xFEFF\n    // - c-flow-indicator\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // - \":\" - \"#\"\n    // /* An ns-char preceding */ \"#\"\n    && c !== CHAR_COLON\n    && ((c !== CHAR_SHARP) || (prev && isNsChar(prev)));\n}\n\n// Simplified test for values allowed as the first character in plain style.\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  return isPrintable(c) && c !== 0xFEFF\n    && !isWhitespace(c) // - s-white\n    // - (c-indicator ::=\n    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”\n    && c !== CHAR_MINUS\n    && c !== CHAR_QUESTION\n    && c !== CHAR_COLON\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “\"”\n    && c !== CHAR_SHARP\n    && c !== CHAR_AMPERSAND\n    && c !== CHAR_ASTERISK\n    && c !== CHAR_EXCLAMATION\n    && c !== CHAR_VERTICAL_LINE\n    && c !== CHAR_EQUALS\n    && c !== CHAR_GREATER_THAN\n    && c !== CHAR_SINGLE_QUOTE\n    && c !== CHAR_DOUBLE_QUOTE\n    // | “%” | “@” | “`”)\n    && c !== CHAR_PERCENT\n    && c !== CHAR_COMMERCIAL_AT\n    && c !== CHAR_GRAVE_ACCENT;\n}\n\n// Determines whether block indentation indicator is required.\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN   = 1,\n    STYLE_SINGLE  = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED  = 4,\n    STYLE_DOUBLE  = 5;\n\n// Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {\n  var i;\n  var char, prev_char;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n  var plain = isPlainSafeFirst(string.charCodeAt(0))\n          && !isWhitespace(string.charCodeAt(string.length - 1));\n\n  if (singleLineOnly) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; i++) {\n      char = string.charCodeAt(i);\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n      plain = plain && isPlainSafe(char, prev_char);\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; i++) {\n      char = string.charCodeAt(i);\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true;\n        // Check if any line can be folded.\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine ||\n            // Foldable line = too long, and not more-indented.\n            (i - previousLineBreak - 1 > lineWidth &&\n             string[previousLineBreak + 1] !== ' ');\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n      plain = plain && isPlainSafe(char, prev_char);\n    }\n    // in case the end is missing a \\n\n    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n      (i - previousLineBreak - 1 > lineWidth &&\n       string[previousLineBreak + 1] !== ' '));\n  }\n  // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    return plain && !testAmbiguousType(string)\n      ? STYLE_PLAIN : STYLE_SINGLE;\n  }\n  // Edge case: block indentation indicator can only have one digit.\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  }\n  // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n}\n\n// Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//    • No ending newline => unaffected; already using strip \"-\" chomping.\n//    • Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\nfunction writeScalar(state, string, level, iskey) {\n  state.dump = (function () {\n    if (string.length === 0) {\n      return \"''\";\n    }\n    if (!state.noCompatMode &&\n        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {\n      return \"'\" + string + \"'\";\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n    var lineWidth = state.lineWidth === -1\n      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n    // Without knowing if keys are implicit/explicit, assume implicit for safety.\n    var singleLineOnly = iskey\n      // No block styles in flow mode.\n      || (state.flowLevel > -1 && level >= state.flowLevel);\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {\n      case STYLE_PLAIN:\n        return string;\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(string, indent));\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string, lineWidth) + '\"';\n      default:\n        throw new YAMLException('impossible error: invalid scalar style');\n    }\n  }());\n}\n\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n  // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n  var clip =          string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : (clip ? '' : '-');\n\n  return indentIndicator + chomp + '\\n';\n}\n\n// (See the note for writeScalar.)\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n}\n\n// Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g;\n\n  // first line (possibly an empty line)\n  var result = (function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }());\n  // If we haven't reached the first content line yet, don't add an extra \\n.\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented;\n\n  // rest of the lines\n  var match;\n  while ((match = lineRe.exec(string))) {\n    var prefix = match[1], line = match[2];\n    moreIndented = (line[0] === ' ');\n    result += prefix\n      + (!prevMoreIndented && !moreIndented && line !== ''\n        ? '\\n' : '')\n      + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n}\n\n// Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line;\n\n  // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n  var match;\n  // start is an inclusive index. end, curr, and next are exclusive.\n  var start = 0, end, curr = 0, next = 0;\n  var result = '';\n\n  // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n  while ((match = breakRe.exec(line))) {\n    next = match.index;\n    // maintain invariant: curr - start <= width\n    if (next - start > width) {\n      end = (curr > start) ? curr : next; // derive end <= length-2\n      result += '\\n' + line.slice(start, end);\n      // skip the space that was output as \\n\n      start = end + 1;                    // derive start <= length-1\n    }\n    curr = next;\n  }\n\n  // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n  result += '\\n';\n  // Insert a break if the remainder is too long and there is a break available.\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n}\n\n// Escapes a double-quoted string.\nfunction escapeString(string) {\n  var result = '';\n  var char, nextChar;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; i++) {\n    char = string.charCodeAt(i);\n    // Check for surrogate pairs (reference Unicode 3.0 section \"3.7 Surrogates\").\n    if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {\n      nextChar = string.charCodeAt(i + 1);\n      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {\n        // Combine the surrogate pair and store it escaped.\n        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);\n        // Advance index one extra since we already used that char here.\n        i++; continue;\n      }\n    }\n    escapeSeq = ESCAPE_SEQUENCES[char];\n    result += !escapeSeq && isPrintable(char)\n      ? string[i]\n      : escapeSeq || encodeHex(char);\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level, object[index], false, false)) {\n      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level + 1, object[index], true, true)) {\n      if (!compact || index !== 0) {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n\n    pairBuffer = '';\n    if (index !== 0) pairBuffer += ', ';\n\n    if (state.condenseFlow) pairBuffer += '\"';\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new YAMLException('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || index !== 0) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = (state.tag !== null && state.tag !== '?') ||\n                   (state.dump && state.dump.length > 1024);\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf  || type.predicate) &&\n        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n        (!type.predicate  || type.predicate(object))) {\n\n      state.tag = explicit ? type.tag : '?';\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact, iskey) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n\n  if (block) {\n    block = (state.flowLevel < 0 || state.flowLevel > level);\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if (type === '[object Object]') {\n      if (block && (Object.keys(state.dump).length !== 0)) {\n        writeBlockMapping(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      var arrayLevel = (state.noArrayIndent && (level > 0)) ? level - 1 : level;\n      if (block && (state.dump.length !== 0)) {\n        writeBlockSequence(state, arrayLevel, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, arrayLevel, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey);\n      }\n    } else {\n      if (state.skipInvalid) return false;\n      throw new YAMLException('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      state.dump = '!<' + state.tag + '> ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList,\n      index,\n      length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump(input, options) {\n  options = options || {};\n\n  var state = new State(options);\n\n  if (!state.noRefs) getDuplicateReferences(input, state);\n\n  if (writeNode(state, 0, input, true, true)) return state.dump + '\\n';\n\n  return '';\n}\n\nfunction safeDump(input, options) {\n  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n}\n\nmodule.exports.dump     = dump;\nmodule.exports.safeDump = safeDump;\n"]},"metadata":{},"sourceType":"script"}