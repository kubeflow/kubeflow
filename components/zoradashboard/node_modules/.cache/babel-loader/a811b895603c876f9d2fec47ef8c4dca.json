{"ast":null,"code":"import zlib from 'zlib';\n\nvar PNG = /*#__PURE__*/function () {\n  PNG.decode = function decode(path, fn) {\n    {\n      throw new Error('PNG.decode not available in browser build');\n    }\n  };\n\n  PNG.load = function load(path) {\n    {\n      throw new Error('PNG.load not available in browser build');\n    }\n  };\n\n  function PNG(data) {\n    var i;\n    this.data = data;\n    this.pos = 8; // Skip the default header\n\n    this.palette = [];\n    this.imgData = [];\n    this.transparency = {};\n    this.text = {};\n\n    while (true) {\n      var chunkSize = this.readUInt32();\n      var section = '';\n\n      for (i = 0; i < 4; i++) {\n        section += String.fromCharCode(this.data[this.pos++]);\n      }\n\n      switch (section) {\n        case 'IHDR':\n          // we can grab  interesting values from here (like width, height, etc)\n          this.width = this.readUInt32();\n          this.height = this.readUInt32();\n          this.bits = this.data[this.pos++];\n          this.colorType = this.data[this.pos++];\n          this.compressionMethod = this.data[this.pos++];\n          this.filterMethod = this.data[this.pos++];\n          this.interlaceMethod = this.data[this.pos++];\n          break;\n\n        case 'PLTE':\n          this.palette = this.read(chunkSize);\n          break;\n\n        case 'IDAT':\n          for (i = 0; i < chunkSize; i++) {\n            this.imgData.push(this.data[this.pos++]);\n          }\n\n          break;\n\n        case 'tRNS':\n          // This chunk can only occur once and it must occur after the\n          // PLTE chunk and before the IDAT chunk.\n          this.transparency = {};\n\n          switch (this.colorType) {\n            case 3:\n              // Indexed color, RGB. Each byte in this chunk is an alpha for\n              // the palette index in the PLTE (\"palette\") chunk up until the\n              // last non-opaque entry. Set up an array, stretching over all\n              // palette entries which will be 0 (opaque) or 1 (transparent).\n              this.transparency.indexed = this.read(chunkSize);\n              var short = 255 - this.transparency.indexed.length;\n\n              if (short > 0) {\n                for (i = 0; i < short; i++) {\n                  this.transparency.indexed.push(255);\n                }\n              }\n\n              break;\n\n            case 0:\n              // Greyscale. Corresponding to entries in the PLTE chunk.\n              // Grey is two bytes, range 0 .. (2 ^ bit-depth) - 1\n              this.transparency.grayscale = this.read(chunkSize)[0];\n              break;\n\n            case 2:\n              // True color with proper alpha channel.\n              this.transparency.rgb = this.read(chunkSize);\n              break;\n          }\n\n          break;\n\n        case 'tEXt':\n          var text = this.read(chunkSize);\n          var index = text.indexOf(0);\n          var key = String.fromCharCode.apply(String, text.slice(0, index));\n          this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));\n          break;\n\n        case 'IEND':\n          // we've got everything we need!\n          switch (this.colorType) {\n            case 0:\n            case 3:\n            case 4:\n              this.colors = 1;\n              break;\n\n            case 2:\n            case 6:\n              this.colors = 3;\n              break;\n          }\n\n          this.hasAlphaChannel = [4, 6].includes(this.colorType);\n          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);\n          this.pixelBitlength = this.bits * colors;\n\n          switch (this.colors) {\n            case 1:\n              this.colorSpace = 'DeviceGray';\n              break;\n\n            case 3:\n              this.colorSpace = 'DeviceRGB';\n              break;\n          }\n\n          this.imgData = Buffer.from(this.imgData);\n          return;\n\n        default:\n          // unknown (or unimportant) section, skip it\n          this.pos += chunkSize;\n      }\n\n      this.pos += 4; // Skip the CRC\n\n      if (this.pos > this.data.length) {\n        throw new Error('Incomplete or corrupt PNG file');\n      }\n    }\n  }\n\n  var _proto = PNG.prototype;\n\n  _proto.read = function read(bytes) {\n    var result = new Array(bytes);\n\n    for (var i = 0; i < bytes; i++) {\n      result[i] = this.data[this.pos++];\n    }\n\n    return result;\n  };\n\n  _proto.readUInt32 = function readUInt32() {\n    var b1 = this.data[this.pos++] << 24;\n    var b2 = this.data[this.pos++] << 16;\n    var b3 = this.data[this.pos++] << 8;\n    var b4 = this.data[this.pos++];\n    return b1 | b2 | b3 | b4;\n  };\n\n  _proto.readUInt16 = function readUInt16() {\n    var b1 = this.data[this.pos++] << 8;\n    var b2 = this.data[this.pos++];\n    return b1 | b2;\n  };\n\n  _proto.decodePixels = function decodePixels(fn) {\n    var _this = this;\n\n    return zlib.inflate(this.imgData, function (err, data) {\n      if (err) throw err;\n      var pos = 0;\n      var width = _this.width,\n          height = _this.height;\n      var pixelBytes = _this.pixelBitlength / 8;\n      var pixels = Buffer.alloc(width * height * pixelBytes);\n\n      function pass(x0, y0, dx, dy, singlePass) {\n        if (singlePass === void 0) {\n          singlePass = false;\n        }\n\n        var w = Math.ceil((width - x0) / dx);\n        var h = Math.ceil((height - y0) / dy);\n        var scanlineLength = pixelBytes * w;\n        var buffer = singlePass ? pixels : Buffer.alloc(scanlineLength * h);\n        var row = 0;\n        var c = 0;\n\n        while (row < h && pos < data.length) {\n          var byte;\n          var col;\n          var i;\n          var left;\n          var upper;\n\n          switch (data[pos++]) {\n            case 0:\n              // None\n              for (i = 0; i < scanlineLength; i++) {\n                buffer[c++] = data[pos++];\n              }\n\n              break;\n\n            case 1:\n              // Sub\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                buffer[c++] = (byte + left) % 256;\n              }\n\n              break;\n\n            case 2:\n              // Up\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                buffer[c++] = (upper + byte) % 256;\n              }\n\n              break;\n\n            case 3:\n              // Average\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                buffer[c++] = (byte + Math.floor((left + upper) / 2)) % 256;\n              }\n\n              break;\n\n            case 4:\n              // Paeth\n              for (i = 0; i < scanlineLength; i++) {\n                var paeth;\n                var upperLeft;\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n\n                if (row === 0) {\n                  upper = upperLeft = 0;\n                } else {\n                  upper = buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                  upperLeft = col && buffer[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];\n                }\n\n                var p = left + upper - upperLeft;\n                var pa = Math.abs(p - left);\n                var pb = Math.abs(p - upper);\n                var pc = Math.abs(p - upperLeft);\n\n                if (pa <= pb && pa <= pc) {\n                  paeth = left;\n                } else if (pb <= pc) {\n                  paeth = upper;\n                } else {\n                  paeth = upperLeft;\n                }\n\n                buffer[c++] = (byte + paeth) % 256;\n              }\n\n              break;\n\n            default:\n              throw new Error(\"Invalid filter algorithm: \" + data[pos - 1]);\n          }\n\n          if (!singlePass) {\n            var pixelsPos = ((y0 + row * dy) * width + x0) * pixelBytes;\n            var bufferPos = row * scanlineLength;\n\n            for (i = 0; i < w; i++) {\n              for (var j = 0; j < pixelBytes; j++) {\n                pixels[pixelsPos++] = buffer[bufferPos++];\n              }\n\n              pixelsPos += (dx - 1) * pixelBytes;\n            }\n          }\n\n          row++;\n        }\n      }\n\n      if (_this.interlaceMethod === 1) {\n        /*\n          1 6 4 6 2 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n          3 6 4 6 3 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n        */\n        pass(0, 0, 8, 8); // 1\n\n        pass(4, 0, 8, 8); // 2\n\n        pass(0, 4, 4, 8); // 3\n\n        pass(2, 0, 4, 4); // 4\n\n        pass(0, 2, 2, 4); // 5\n\n        pass(1, 0, 2, 2); // 6\n\n        pass(0, 1, 1, 2); // 7\n      } else {\n        pass(0, 0, 1, 1, true);\n      }\n\n      return fn(pixels);\n    });\n  };\n\n  _proto.decodePalette = function decodePalette() {\n    var palette = this.palette;\n    var length = palette.length;\n    var transparency = this.transparency.indexed || [];\n    var ret = Buffer.alloc(transparency.length + length);\n    var pos = 0;\n    var c = 0;\n\n    for (var i = 0; i < length; i += 3) {\n      var left;\n      ret[pos++] = palette[i];\n      ret[pos++] = palette[i + 1];\n      ret[pos++] = palette[i + 2];\n      ret[pos++] = (left = transparency[c++]) != null ? left : 255;\n    }\n\n    return ret;\n  };\n\n  _proto.copyToImageData = function copyToImageData(imageData, pixels) {\n    var j;\n    var k;\n    var colors = this.colors;\n    var palette = null;\n    var alpha = this.hasAlphaChannel;\n\n    if (this.palette.length) {\n      palette = this._decodedPalette || (this._decodedPalette = this.decodePalette());\n      colors = 4;\n      alpha = true;\n    }\n\n    var data = imageData.data || imageData;\n    var length = data.length;\n    var input = palette || pixels;\n    var i = j = 0;\n\n    if (colors === 1) {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        var v = input[k++];\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    } else {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    }\n  };\n\n  _proto.decode = function decode(fn) {\n    var _this2 = this;\n\n    var ret = Buffer.alloc(this.width * this.height * 4);\n    return this.decodePixels(function (pixels) {\n      _this2.copyToImageData(ret, pixels);\n\n      return fn(ret);\n    });\n  };\n\n  return PNG;\n}();\n\nexport default PNG;","map":{"version":3,"sources":["/Users/allan.chepkoy/cloud/kubeflow/components/zoradashboard/node_modules/@react-pdf/png-js/lib/png-js.browser.es.js"],"names":["zlib","PNG","decode","path","fn","Error","load","data","i","pos","palette","imgData","transparency","text","chunkSize","readUInt32","section","String","fromCharCode","width","height","bits","colorType","compressionMethod","filterMethod","interlaceMethod","read","push","indexed","short","length","grayscale","rgb","index","indexOf","key","apply","slice","colors","hasAlphaChannel","includes","pixelBitlength","colorSpace","Buffer","from","_proto","prototype","bytes","result","Array","b1","b2","b3","b4","readUInt16","decodePixels","_this","inflate","err","pixelBytes","pixels","alloc","pass","x0","y0","dx","dy","singlePass","w","Math","ceil","h","scanlineLength","buffer","row","c","byte","col","left","upper","floor","paeth","upperLeft","p","pa","abs","pb","pc","pixelsPos","bufferPos","j","decodePalette","ret","copyToImageData","imageData","k","alpha","_decodedPalette","input","v","_this2"],"mappings":"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","sourcesContent":["import zlib from 'zlib';\n\nvar PNG = /*#__PURE__*/function () {\n  PNG.decode = function decode(path, fn) {\n    {\n      throw new Error('PNG.decode not available in browser build');\n    }\n  };\n\n  PNG.load = function load(path) {\n    {\n      throw new Error('PNG.load not available in browser build');\n    }\n  };\n\n  function PNG(data) {\n    var i;\n    this.data = data;\n    this.pos = 8; // Skip the default header\n\n    this.palette = [];\n    this.imgData = [];\n    this.transparency = {};\n    this.text = {};\n\n    while (true) {\n      var chunkSize = this.readUInt32();\n      var section = '';\n\n      for (i = 0; i < 4; i++) {\n        section += String.fromCharCode(this.data[this.pos++]);\n      }\n\n      switch (section) {\n        case 'IHDR':\n          // we can grab  interesting values from here (like width, height, etc)\n          this.width = this.readUInt32();\n          this.height = this.readUInt32();\n          this.bits = this.data[this.pos++];\n          this.colorType = this.data[this.pos++];\n          this.compressionMethod = this.data[this.pos++];\n          this.filterMethod = this.data[this.pos++];\n          this.interlaceMethod = this.data[this.pos++];\n          break;\n\n        case 'PLTE':\n          this.palette = this.read(chunkSize);\n          break;\n\n        case 'IDAT':\n          for (i = 0; i < chunkSize; i++) {\n            this.imgData.push(this.data[this.pos++]);\n          }\n\n          break;\n\n        case 'tRNS':\n          // This chunk can only occur once and it must occur after the\n          // PLTE chunk and before the IDAT chunk.\n          this.transparency = {};\n\n          switch (this.colorType) {\n            case 3:\n              // Indexed color, RGB. Each byte in this chunk is an alpha for\n              // the palette index in the PLTE (\"palette\") chunk up until the\n              // last non-opaque entry. Set up an array, stretching over all\n              // palette entries which will be 0 (opaque) or 1 (transparent).\n              this.transparency.indexed = this.read(chunkSize);\n              var short = 255 - this.transparency.indexed.length;\n\n              if (short > 0) {\n                for (i = 0; i < short; i++) {\n                  this.transparency.indexed.push(255);\n                }\n              }\n\n              break;\n\n            case 0:\n              // Greyscale. Corresponding to entries in the PLTE chunk.\n              // Grey is two bytes, range 0 .. (2 ^ bit-depth) - 1\n              this.transparency.grayscale = this.read(chunkSize)[0];\n              break;\n\n            case 2:\n              // True color with proper alpha channel.\n              this.transparency.rgb = this.read(chunkSize);\n              break;\n          }\n\n          break;\n\n        case 'tEXt':\n          var text = this.read(chunkSize);\n          var index = text.indexOf(0);\n          var key = String.fromCharCode.apply(String, text.slice(0, index));\n          this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));\n          break;\n\n        case 'IEND':\n          // we've got everything we need!\n          switch (this.colorType) {\n            case 0:\n            case 3:\n            case 4:\n              this.colors = 1;\n              break;\n\n            case 2:\n            case 6:\n              this.colors = 3;\n              break;\n          }\n\n          this.hasAlphaChannel = [4, 6].includes(this.colorType);\n          var colors = this.colors + (this.hasAlphaChannel ? 1 : 0);\n          this.pixelBitlength = this.bits * colors;\n\n          switch (this.colors) {\n            case 1:\n              this.colorSpace = 'DeviceGray';\n              break;\n\n            case 3:\n              this.colorSpace = 'DeviceRGB';\n              break;\n          }\n\n          this.imgData = Buffer.from(this.imgData);\n          return;\n\n        default:\n          // unknown (or unimportant) section, skip it\n          this.pos += chunkSize;\n      }\n\n      this.pos += 4; // Skip the CRC\n\n      if (this.pos > this.data.length) {\n        throw new Error('Incomplete or corrupt PNG file');\n      }\n    }\n  }\n\n  var _proto = PNG.prototype;\n\n  _proto.read = function read(bytes) {\n    var result = new Array(bytes);\n\n    for (var i = 0; i < bytes; i++) {\n      result[i] = this.data[this.pos++];\n    }\n\n    return result;\n  };\n\n  _proto.readUInt32 = function readUInt32() {\n    var b1 = this.data[this.pos++] << 24;\n    var b2 = this.data[this.pos++] << 16;\n    var b3 = this.data[this.pos++] << 8;\n    var b4 = this.data[this.pos++];\n    return b1 | b2 | b3 | b4;\n  };\n\n  _proto.readUInt16 = function readUInt16() {\n    var b1 = this.data[this.pos++] << 8;\n    var b2 = this.data[this.pos++];\n    return b1 | b2;\n  };\n\n  _proto.decodePixels = function decodePixels(fn) {\n    var _this = this;\n\n    return zlib.inflate(this.imgData, function (err, data) {\n      if (err) throw err;\n      var pos = 0;\n      var width = _this.width,\n          height = _this.height;\n      var pixelBytes = _this.pixelBitlength / 8;\n      var pixels = Buffer.alloc(width * height * pixelBytes);\n\n      function pass(x0, y0, dx, dy, singlePass) {\n        if (singlePass === void 0) {\n          singlePass = false;\n        }\n\n        var w = Math.ceil((width - x0) / dx);\n        var h = Math.ceil((height - y0) / dy);\n        var scanlineLength = pixelBytes * w;\n        var buffer = singlePass ? pixels : Buffer.alloc(scanlineLength * h);\n        var row = 0;\n        var c = 0;\n\n        while (row < h && pos < data.length) {\n          var byte;\n          var col;\n          var i;\n          var left;\n          var upper;\n\n          switch (data[pos++]) {\n            case 0:\n              // None\n              for (i = 0; i < scanlineLength; i++) {\n                buffer[c++] = data[pos++];\n              }\n\n              break;\n\n            case 1:\n              // Sub\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                buffer[c++] = (byte + left) % 256;\n              }\n\n              break;\n\n            case 2:\n              // Up\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                buffer[c++] = (upper + byte) % 256;\n              }\n\n              break;\n\n            case 3:\n              // Average\n              for (i = 0; i < scanlineLength; i++) {\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n                upper = row && buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                buffer[c++] = (byte + Math.floor((left + upper) / 2)) % 256;\n              }\n\n              break;\n\n            case 4:\n              // Paeth\n              for (i = 0; i < scanlineLength; i++) {\n                var paeth;\n                var upperLeft;\n                byte = data[pos++];\n                col = (i - i % pixelBytes) / pixelBytes;\n                left = i < pixelBytes ? 0 : buffer[c - pixelBytes];\n\n                if (row === 0) {\n                  upper = upperLeft = 0;\n                } else {\n                  upper = buffer[(row - 1) * scanlineLength + col * pixelBytes + i % pixelBytes];\n                  upperLeft = col && buffer[(row - 1) * scanlineLength + (col - 1) * pixelBytes + i % pixelBytes];\n                }\n\n                var p = left + upper - upperLeft;\n                var pa = Math.abs(p - left);\n                var pb = Math.abs(p - upper);\n                var pc = Math.abs(p - upperLeft);\n\n                if (pa <= pb && pa <= pc) {\n                  paeth = left;\n                } else if (pb <= pc) {\n                  paeth = upper;\n                } else {\n                  paeth = upperLeft;\n                }\n\n                buffer[c++] = (byte + paeth) % 256;\n              }\n\n              break;\n\n            default:\n              throw new Error(\"Invalid filter algorithm: \" + data[pos - 1]);\n          }\n\n          if (!singlePass) {\n            var pixelsPos = ((y0 + row * dy) * width + x0) * pixelBytes;\n            var bufferPos = row * scanlineLength;\n\n            for (i = 0; i < w; i++) {\n              for (var j = 0; j < pixelBytes; j++) {\n                pixels[pixelsPos++] = buffer[bufferPos++];\n              }\n\n              pixelsPos += (dx - 1) * pixelBytes;\n            }\n          }\n\n          row++;\n        }\n      }\n\n      if (_this.interlaceMethod === 1) {\n        /*\n          1 6 4 6 2 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n          3 6 4 6 3 6 4 6\n          7 7 7 7 7 7 7 7\n          5 6 5 6 5 6 5 6\n          7 7 7 7 7 7 7 7\n        */\n        pass(0, 0, 8, 8); // 1\n\n        pass(4, 0, 8, 8); // 2\n\n        pass(0, 4, 4, 8); // 3\n\n        pass(2, 0, 4, 4); // 4\n\n        pass(0, 2, 2, 4); // 5\n\n        pass(1, 0, 2, 2); // 6\n\n        pass(0, 1, 1, 2); // 7\n      } else {\n        pass(0, 0, 1, 1, true);\n      }\n\n      return fn(pixels);\n    });\n  };\n\n  _proto.decodePalette = function decodePalette() {\n    var palette = this.palette;\n    var length = palette.length;\n    var transparency = this.transparency.indexed || [];\n    var ret = Buffer.alloc(transparency.length + length);\n    var pos = 0;\n    var c = 0;\n\n    for (var i = 0; i < length; i += 3) {\n      var left;\n      ret[pos++] = palette[i];\n      ret[pos++] = palette[i + 1];\n      ret[pos++] = palette[i + 2];\n      ret[pos++] = (left = transparency[c++]) != null ? left : 255;\n    }\n\n    return ret;\n  };\n\n  _proto.copyToImageData = function copyToImageData(imageData, pixels) {\n    var j;\n    var k;\n    var colors = this.colors;\n    var palette = null;\n    var alpha = this.hasAlphaChannel;\n\n    if (this.palette.length) {\n      palette = this._decodedPalette || (this._decodedPalette = this.decodePalette());\n      colors = 4;\n      alpha = true;\n    }\n\n    var data = imageData.data || imageData;\n    var length = data.length;\n    var input = palette || pixels;\n    var i = j = 0;\n\n    if (colors === 1) {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        var v = input[k++];\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = v;\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    } else {\n      while (i < length) {\n        k = palette ? pixels[i / 4] * 4 : j;\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = input[k++];\n        data[i++] = alpha ? input[k++] : 255;\n        j = k;\n      }\n    }\n  };\n\n  _proto.decode = function decode(fn) {\n    var _this2 = this;\n\n    var ret = Buffer.alloc(this.width * this.height * 4);\n    return this.decodePixels(function (pixels) {\n      _this2.copyToImageData(ret, pixels);\n\n      return fn(ret);\n    });\n  };\n\n  return PNG;\n}();\n\nexport default PNG;\n"]},"metadata":{},"sourceType":"module"}