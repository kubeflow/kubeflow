{"ast":null,"code":"\"use strict\";\n/**\n * Naive, simple plugin to match inline nodes without attributes\n * This allows say <strong>foo</strong>, but not <strong class=\"very\">foo</strong>\n * For proper HTML support, you'll want a different plugin\n **/\n\nvar visit = require('unist-util-visit');\n\nvar type = 'virtualHtml';\nvar selfClosingRe = /^<(area|base|br|col|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)\\s*\\/?>$/i;\nvar simpleTagRe = /^<(\\/?)([a-z]+)\\s*>$/;\n\nmodule.exports = function (tree) {\n  var open;\n  var currentParent;\n  visit(tree, 'html', function (node, index, parent) {\n    if (currentParent !== parent) {\n      open = [];\n      currentParent = parent;\n    }\n\n    var selfClosing = getSelfClosing(node);\n\n    if (selfClosing) {\n      parent.children.splice(index, 1, {\n        type: type,\n        tag: selfClosing,\n        position: node.position\n      });\n      return true;\n    }\n\n    var current = getSimpleTag(node, parent);\n\n    if (!current) {\n      return true;\n    }\n\n    var matching = findAndPull(open, current.tag);\n\n    if (matching) {\n      parent.children.splice(index, 0, virtual(current, matching, parent));\n    } else if (!current.opening) {\n      open.push(current);\n    }\n\n    return true;\n  }, true // Iterate in reverse\n  );\n  return tree;\n};\n\nfunction findAndPull(open, matchingTag) {\n  var i = open.length;\n\n  while (i--) {\n    if (open[i].tag === matchingTag) {\n      return open.splice(i, 1)[0];\n    }\n  }\n\n  return false;\n}\n\nfunction getSimpleTag(node, parent) {\n  var match = node.value.match(simpleTagRe);\n  return match ? {\n    tag: match[2],\n    opening: !match[1],\n    node: node\n  } : false;\n}\n\nfunction getSelfClosing(node) {\n  var match = node.value.match(selfClosingRe);\n  return match ? match[1] : false;\n}\n\nfunction virtual(fromNode, toNode, parent) {\n  var fromIndex = parent.children.indexOf(fromNode.node);\n  var toIndex = parent.children.indexOf(toNode.node);\n  var extracted = parent.children.splice(fromIndex, toIndex - fromIndex + 1);\n  var children = extracted.slice(1, -1);\n  return {\n    type: type,\n    children: children,\n    tag: fromNode.tag,\n    position: {\n      start: fromNode.node.position.start,\n      end: toNode.node.position.end,\n      indent: []\n    }\n  };\n}","map":{"version":3,"sources":["/Users/allan.chepkoy/cloud/kubeflow/components/zoradashboard/node_modules/react-markdown/lib/plugins/naive-html.js"],"names":["visit","require","type","selfClosingRe","simpleTagRe","module","exports","tree","open","currentParent","node","index","parent","selfClosing","getSelfClosing","children","splice","tag","position","current","getSimpleTag","matching","findAndPull","virtual","opening","push","matchingTag","i","length","match","value","fromNode","toNode","fromIndex","indexOf","toIndex","extracted","slice","start","end","indent"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/**\n * Naive, simple plugin to match inline nodes without attributes\n * This allows say <strong>foo</strong>, but not <strong class=\"very\">foo</strong>\n * For proper HTML support, you'll want a different plugin\n **/\nvar visit = require('unist-util-visit');\n\nvar type = 'virtualHtml';\nvar selfClosingRe = /^<(area|base|br|col|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)\\s*\\/?>$/i;\nvar simpleTagRe = /^<(\\/?)([a-z]+)\\s*>$/;\n\nmodule.exports = function (tree) {\n  var open;\n  var currentParent;\n  visit(tree, 'html', function (node, index, parent) {\n    if (currentParent !== parent) {\n      open = [];\n      currentParent = parent;\n    }\n\n    var selfClosing = getSelfClosing(node);\n\n    if (selfClosing) {\n      parent.children.splice(index, 1, {\n        type: type,\n        tag: selfClosing,\n        position: node.position\n      });\n      return true;\n    }\n\n    var current = getSimpleTag(node, parent);\n\n    if (!current) {\n      return true;\n    }\n\n    var matching = findAndPull(open, current.tag);\n\n    if (matching) {\n      parent.children.splice(index, 0, virtual(current, matching, parent));\n    } else if (!current.opening) {\n      open.push(current);\n    }\n\n    return true;\n  }, true // Iterate in reverse\n  );\n  return tree;\n};\n\nfunction findAndPull(open, matchingTag) {\n  var i = open.length;\n\n  while (i--) {\n    if (open[i].tag === matchingTag) {\n      return open.splice(i, 1)[0];\n    }\n  }\n\n  return false;\n}\n\nfunction getSimpleTag(node, parent) {\n  var match = node.value.match(simpleTagRe);\n  return match ? {\n    tag: match[2],\n    opening: !match[1],\n    node: node\n  } : false;\n}\n\nfunction getSelfClosing(node) {\n  var match = node.value.match(selfClosingRe);\n  return match ? match[1] : false;\n}\n\nfunction virtual(fromNode, toNode, parent) {\n  var fromIndex = parent.children.indexOf(fromNode.node);\n  var toIndex = parent.children.indexOf(toNode.node);\n  var extracted = parent.children.splice(fromIndex, toIndex - fromIndex + 1);\n  var children = extracted.slice(1, -1);\n  return {\n    type: type,\n    children: children,\n    tag: fromNode.tag,\n    position: {\n      start: fromNode.node.position.start,\n      end: toNode.node.position.end,\n      indent: []\n    }\n  };\n}"]},"metadata":{},"sourceType":"script"}